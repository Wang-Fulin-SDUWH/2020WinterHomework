#Review C

[toc]

##杂项

###void 类型

void 类型指定没有可用的值。它通常用于以下三种情况下：

| 序号 | 类型与描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **函数返回为空** C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 **void exit (int status);** |
| 2    | **函数参数为空** C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 **int rand(void);** |
| 3    | **指针指向 void** 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 **void \*malloc( size_t size );** 返回指向 void 的指针，可以转换为任何数据类型。 |

###基本类型书写

####整数

-  a，默认为10进制 ，10 ，20。
-  b，以0开头为8进制，045，021。
-  c.，以0b开头为2进制，0b11101101。
-  d，以0x开头为16进制，0x21458adf。

#### 小数

- 单精度常量：2.3f 。

- 双精度常量：2.3，默认为双精度。

###多个C文件编写

如果需要在一个源文件中引用另外一个源文件中定义的变量，我们只需在引用的文件中将变量加上 extern 关键字的声明即可。

####addtwonum.c 文件代码：

```c
#include <stdio.h> /*外部变量声明*/ 
extern int x ; 
extern int y ; 
int addtwonum() 
{    
  return x+y; 
}
```

####test.c 文件代码：

```C
#include <stdio.h>
  
/*定义两个全局变量*/
int x=1;
int y=2;
int addtwonum();
int main(void)
{
    int result;
    result = addtwonum();
    printf("result 为: %d\n",result);
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
$ gcc addtwonum.c test.c -o main
$ ./main
result 为: 3
```

### srand初始化随机种子（机器学习重点！！）：

srand((unsigned)time(NULL))是初始化随机函数种子：

-  1、是拿当前系统时间作为种子，由于时间是变化的，种子变化，可以产生不相同的随机数。计算机中的随机数实际上都不是真正的随机数，如果两次给的种子一样，是会生成同样的随机序列的。 所以，一般都会以当前的时间作为种子来生成随机数，这样更加的随机。
-  2、使用时，参数可以是unsigned型的任意数据，比如srand（10）； 
-  3、如果不使用srand，用rand（）产生的随机数，在多次运行，结果是一样的。

参考如下：

```C
void test_rand(void)
{
    unsigned long n;
    srand((unsigned)time(NULL));//该语句使得每次生成的随机数不同，因为每次的种子不同
  	//srand(10);//该语句固定种子，使每次生成的随机数相同
    for(int i = 0; i < 100; i++)
    {
        n = rand();
        printf("d\n", n);
    }
}
```

## C存储类

存储类定义 C 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C 程序中可用的存储类：

- auto
- register
- static
- extern

####auto 存储类

**auto** 存储类是所有局部变量默认的存储类。

```
{
   int mount;
   auto int month;
}
```

上面的实例定义了两个带有相同存储类的变量，auto 只能用在函数内，即 auto 只能修饰局部变量。

####register 存储类

**register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

```
{
   register int  miles;
}
```

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

####static 存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而**不需要在每次它进入和离开作用域时进行创建和销毁**。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使**变量的作用域限制在声明它的文件内**。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

以下实例演示了 static 修饰全局变量和局部变量的应用：

```c
/****************************************重要实例！****************************************/
#include <stdio.h>
 
/* 函数声明 */
void func1(void);
 
static int count=10;        /* 全局变量 - static 是默认的 */
 
int main()
{
  while (count--) {
      func1();
  }
  return 0;
}
 
void func1(void)
{
/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次
 * 每次调用函数 'func1' 'thingy' 值不会被重置。
 */                
  static int thingy=5;
  thingy++;
  printf(" thingy 为 %d ， count 为 %d\n", thingy, count);
}
```

实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。

```
thingy 为 6 ， count 为 9
 thingy 为 7 ， count 为 8
 thingy 为 8 ， count 为 7
 thingy 为 9 ， count 为 6
 thingy 为 10 ， count 为 5
 thingy 为 11 ， count 为 4
 thingy 为 12 ， count 为 3
 thingy 为 13 ， count 为 2
 thingy 为 14 ， count 为 1
 thingy 为 15 ， count 为 0
```

##### 总结：

（1）static修饰局部变量

一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。

```
#include <stdio.h>

void varfunc(void)
{
    int var=0;
    static int static_var=0;
    printf("var equal: %d\n",var);
    printf("static_var equal: %d\n",static_var);
    printf("");
    var++;
    static_var++;
}

int main(int argc, char *argv[])
{
    int i;
    for(i=0;i<3;i++)
        varfunc();
    return 0;
}
```

运行结果如下：

```
var equal: 0
static_var equal: 0
var equal: 0
static_var equal: 1
var equal: 0
static_var equal: 2
```

**这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。**Eg：如果在自定义函数中用static声明a，直接在main中是无法调用的。

（2）static修饰全局变量

如上例。

另外，对于一个extern型全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。

（3）static 的第三个作用是默认初始化为 0。

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 **0x00**，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置 **0**，然后把不是 **0** 的几个元素赋值。如果定义成静态的，就省去了一开始置 **0** 的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加 **\0** 太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 **\0** 。

####extern 存储类

**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 **extern** 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 *extern* 来得到已定义的变量或函数的引用。可以这么理解，*extern* 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当**有两个或多个文件共享相同的全局变量或函数的时候**，如下所示：

**第一个文件：main.c**

```c
#include <stdio.h>
 
int count ;
extern void write_extern();
 
int main()
{
   count = 5;
   write_extern();
}
```

**第二个文件：support.c**

```c
#include <stdio.h>
 
extern int count;
 
void write_extern(void)
{
   printf("count is %d\n", count);
}
```

在这里，第二个文件中的 *extern* 关键字用于声明已经在第一个文件 main.c 中定义的 *count*。现在 ，编译这两个文件，如下所示：

```
 $ gcc main.c support.c
```

这会产生 **a.out** 可执行程序，当程序被执行时，它会产生下列结果：

```
count is 5
```

如果把support里面的extern改为static，则main中无法调用。

## C运算符

###位运算符

位运算符作用于位，并**逐位执行操作**。&、 | 和 ^ 的真值表如下所示：

| p    | q    | p & q | p \| q | p ^ q |
| :--- | :--- | :---- | :----- | :---- |
| 0    | 0    | 0     | 0      | 0     |
| 0    | 1    | 0     | 1      | 1     |
| 1    | 1    | 1     | 1      | 0     |
| 1    | 0    | 0     | 1      | 1     |

假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

A = 0011 1100

B = 0000 1101

\-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011

下表显示了 C 语言支持的位运算符。假设变量 **A** 的值为 60，变量 **B** 的值为 13，则：

| 运算符 | 描述                                                         | 实例                                                         |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| &      | 按位与操作，按二进制位进行"与"运算。运算规则：`0&0=0;    0&1=0;     1&0=0;      1&1=1;` | (A & B) 将得到 12，即为 0000 1100                            |
| \|     | 按位或运算符，按二进制位进行"或"运算。运算规则：`0|0=0;    0|1=1;    1|0=1;     1|1=1;` | (A \| B) 将得到 61，即为 0011 1101                           |
| ^      | 异或运算符，按二进制位进行"异或"运算。运算规则：`0^0=0;    0^1=1;    1^0=1;   1^1=0;` | (A ^ B) 将得到 49，即为 0011 0001                            |
| ~      | 取反运算符，按二进制位进行"取反"运算。运算规则：`~1=0;    ~0=1;` | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| <<     | 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000                            |
| >>     | 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，**负数左补1，右边丢弃**。 | A >> 2 将得到 15，即为 0000 1111                             |

```简体中文
对于~60=-61的解释：
int类型是4字节，表示-2^31 ~ 2^31-1

我们设定一个变量60，看它各运算后的结果

60的二进制表示为00000000 00000000 00000000 00111100

~60，我们对60取反，得到这样的二进制11111111 11111111 11111111 11000011

首位的比特位是1，表示这是一个负数，C语言中的负数是补码表示，我们需要讲补码转为原码才知道该二进制在C语言中表示什么编码

补码是反码+1，因此反码为11111111 11111111 11111111 11000010

原码为反码除符号位外其他位求反，因此，原码为10000000 00000000 00000000 00111101，即-61
```

### 其他运算符

下表列出了 C 语言支持的其他一些重要的运算符，包括 **sizeof** 和 **? :**。

| 运算符   | 描述             | 实例                                 |
| :------- | :--------------- | :----------------------------------- |
| sizeof() | 返回变量的大小。 | sizeof(a) 将返回 4，其中 a 是整数。  |
| &        | 返回变量的地址。 | &a; 将给出变量的实际地址。           |
| *        | 指向一个变量。   | *a; 将指向一个变量。                 |
| ? :      | 条件表达式       | 如果条件为真 ? 则值为 X : 否则值为 Y |

####实例

请看下面的实例，了解 C 语言中所有可用的杂项运算符：

```C
请看下面的实例，了解 C 语言中所有可用的杂项运算符：
实例
#include <stdio.h>
 
int main()
{
   int a = 4;
   short b;
   double c;
   int* ptr;
 
   /* sizeof 运算符实例 */
   printf("Line 1 - 变量 a 的大小 = %lu\n", sizeof(a) );
   printf("Line 2 - 变量 b 的大小 = %lu\n", sizeof(b) );
   printf("Line 3 - 变量 c 的大小 = %lu\n", sizeof(c) );
 
   /* & 和 * 运算符实例 */
   ptr = &a;    /* 'ptr' 现在包含 'a' 的地址 */
   printf("a 的值是 %d\n", a);
   printf("*ptr 是 %d\n", *ptr);
 
   /* 三元运算符实例 */
   a = 10;
   b = (a == 1) ? 20: 30;
   printf( "b 的值是 %d\n", b );
 
   b = (a == 10) ? 20: 30;
   printf( "b 的值是 %d\n", b );
}

```

当上面的代码被编译和执行时，它会产生下列结果：

```
Line 1 - 变量 a 的大小 = 4
Line 2 - 变量 b 的大小 = 2
Line 3 - 变量 c 的大小 = 8
a 的值是 4
*ptr 是 4
b 的值是 30
b 的值是 20
```

###C 中的运算符优先级

运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。

例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。

下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。

| 类别       | 运算符                            | 结合性   |
| :--------- | :-------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                 | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)* & sizeof   | 从右到左 |
| 乘除       | * / %                             | 从左到右 |
| 加减       | + -                               | 从左到右 |
| 移位       | << >>                             | 从左到右 |
| 关系       | < <= > >=                         | 从左到右 |
| 相等       | == !=                             | 从左到右 |
| 位与 AND   | &                                 | 从左到右 |
| 位异或 XOR | ^                                 | 从左到右 |
| 位或 OR    | \|                                | 从左到右 |
| 逻辑与 AND | &&                                | 从左到右 |
| 逻辑或 OR  | \|\|                              | 从左到右 |
| 条件       | ?:                                | 从右到左 |
| 赋值       | = += -= *= /= %=>>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                 | 从左到右 |

上表作为参考，只需注意?:是从左到右。

#### 几个奇怪的应用

（1）异或

利用异或 **^** 来交换两个数的值，而且不引入其他变量。

```C
unsigned int a=60;  //0011 1100
unsigned int b=13;  //0000 1101
a=a^b;              //a=a^b=0011 0001
b=a^b;              //b=a^b=0011 1100  相当于b1=(a^b)^b
a=a^b;              //a=a^b=0000 1101  相当于a1=(a^b)^((a^b)^b)
```

实例

```C
#include<stdio.h>

int main( )
{
    unsigned int a=60;         //0011 1100
    unsigned int b=13;         //0000 1101
    printf("a=%d,b=%d",a,b);   //输出a，b的值
    printf("\n");
    a=a^b;                     //a=a^b=0011 0001
    b=a^b;                     //b=a^b=0011 1100
    a=a^b;                     //a=a^b=0000 1101
    printf("a=%d,b=%d",a,b);   //输出a，b的值
}
```

结果：

```
a=60，b=13；
a=13，b=60；
```

（2）判断2的幂

利用位与 **&** 运算，判断一个整数是否是2的整数次幂。

二进制数的位权是以2为底的幂，如果一个整数 m 是 2 的 n 次幂，那么转换为二进制之后只有最高位为 1，其余位置为 0，再观察 m-1 转换为二进制后的形式以及 m&(m-1) 的结果，例如：

```
2 --> 0000 0010        1 --> 0000 0001        2&1 --> 0000 0010 & 0000 0001 = 0
4 --> 0000 0100        3 --> 0000 0011        4&3 --> 0000 0100 & 0000 0011 = 0
8 --> 0000 1000        7 --> 0000 0111        8&7 --> 0000 1000 & 0000 0111 = 0
```

可以看出所有的 1 完美的错过了，根据位与的特点可知 m&(m-1) 的结果为 0。

如果整数 m 不是 2 的 n 次幂，结果会怎样呢？例如 m=9 时：

```
9 --> 0000 1001        8 --> 0000 1000        9&8 --> 0000 1001 & 0000 1000 != 0
```

利用这一特点，即可判断一个整数是否是2的整数次幂。

示例：

```C
int func(int num)
{
    return ((num > 0) && ((num & (num - 1)) == 0));//2的n次幂大于0
}
//返回值为 1，则输入的正整数为 2 的整数次幂，返回值为 0 则不是。
```

## C判断

只说一下switch语句，以免翻车。

####语法

C 语言中 **switch** 语句的语法：

switch(expression){    case constant-expression  :       statement(s);       break; /* 可选的 */    case constant-expression  :       statement(s);       break; /* 可选的 */      /* 您可以有任意数量的 case 语句 */    default : /* 可选的 */       statement(s); }

**switch** 语句必须遵循下面的规则：

- **switch** 语句中的 **expression** 是一个常量表达式，必须是一个整型或枚举类型。
- 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
- case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
- 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
- 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
- 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
- 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。

不加break的示例：

```C
#include <stdio.h>
 
int main ()
{
   /* 局部变量定义 */
   char grade = 'B';
 
   switch(grade)
   {
   case 'A' :
      printf("很棒！\n" );
      break;
   case 'B' :
   case 'C' :
      printf("做得好\n" );
      break;
   case 'D' :
      printf("您通过了\n" );
      break;
   case 'F' :
      printf("最好再试一下\n" );
      break;
   default :
      printf("无效的成绩\n" );
   }
   printf("您的成绩是 %c\n", grade );
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
做得好
您的成绩是 B
```

白嫖：

```C
/*
**使用 switch 语句编程，根据输入的年份判断是否为闰年，根据输入的月份判断这月有多少天。
*/
#include<stdio.h>

int main() {
    int year, month, ex;
    printf("请输入年份及月份（空格分隔）：");
    scanf("%d %d", &year, &month);
    if(month < 1 || month > 12) {
        printf("输入有误！！");
    } else {
        if((year%4 == 0 && year%100 != 0) || year%400 == 0) {
            ex = 1;
            printf("%d年为闰年。\n", year);

        } else {
            ex = 0;
            printf("%d年不为闰年。\n", year);
        }

        switch(month) {
            case 4: case 6: case 9: case 11: printf("%d月有%d天。", month, 30); break;
            case 2: printf("%d月有%d天。", month, 27+ex); break;
            default: printf("%d月有%d天。", month, 31);
        }
    }
}
```

## C函数

```C
#include <stdio.h>
 
/* 函数声明 */
int max(int num1, int num2);
 
int main ()
{
   /* 局部变量定义 */
   int a = 100;
   int b = 200;
   int ret;
 
   /* 调用函数来获取最大值 */
   ret = max(a, b);
 
   printf( "Max value is : %d\n", ret );
 
   return 0;
}
 
/* 函数返回两个数中较大的那个数 */
int max(int num1, int num2) 
{
   /* 局部变量声明 */
   int result;
 
   if (num1 > num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}
```

### C的形参和实参

**概念：**从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反。

```c
#include <stdio.h>

int test(int,int); // 形参，只声明

int main()
{
    int a,b;
    printf("%d",test(5,3)); // 实参，已赋值
}

int test(int a,int b) // 形参
{
    a=a+b;
    return a;
}
```

像上面在 test() 函数里只声明了值为参数的变量，而 main() 函数里则对它赋了值。

```
实参与形参类型相同或赋值兼容。
在调用函数过程中发生的实参与形参之间的数据传递，常称为“虚实结合”
在定义函数中制定的形参，在没有出现函数调用时不占用内存中的存储单元。在函数调用时才分配内存
将实参的值传递给形参
在执行函数时，由于形参已经有值。可以用形参进行运算。
通过return语句将函数值返回，若无返回值，则无return

！！！！调用结束后，形参被释放掉，实参保留原值（单向传值）！！！！！
```



###以交换数字为例的函数调用：

### C传值方式调用函数

向函数传递参数的**传值调用**方法，把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。

默认情况下，C 语言使用*传值调用*方法来传递参数。一般来说，这意味着函数内的代码不会改变用于调用函数的实际参数。函数 **swap()** 定义如下：

```
/* 函数定义 */
void swap(int x, int y)
{
   int temp;

   temp = x; /* 保存 x 的值 */
   x = y;    /* 把 y 赋值给 x */
   y = temp; /* 把 temp 赋值给 y */
  
   return;
}
```

现在，让我们通过传递实际参数来调用函数 **swap()**：



```C
#include <stdio.h>
void swap(int x, int y);
 
int main ()
{
  */\* 局部变量定义 \*/*
  int a = 100;
  int b = 200;
 
  printf("交换前，a 的值： %d**\n**", a );
  printf("交换前，b 的值： %d**\n**", b );
 
  */\* 调用函数来交换值 \*/*
  swap(a, b);
 
  printf("交换后，a 的值： %d**\n**", a );
  printf("交换后，b 的值： %d**\n**", b );
 
  return 0;
}
```



当上面的代码被编译和执行时，它会产生下列结果：

```
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 100
交换后，b 的值： 200
```

上面的实例表明了，虽然在函数内改变了 a 和 b 的值，但是实际上 a 和 b 的值没有发生变化。

### C引用方式调用函数

通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。

```
/* 函数定义 */
void swap(int *x, int *y)
{
   int temp;
   temp = *x;    /* 保存地址 x 的值 */
   *x = *y;      /* 把 y 赋值给 x */
   *y = temp;    /* 把 temp 赋值给 y */
  
   return;
}
```

现在，让我们通过引用传值来调用函数 **swap()**：

```c
#include <stdio.h>
 
/* 函数声明 */
void swap(int *x, int *y);
 
int main ()
{
   /* 局部变量定义 */
   int a = 100;
   int b = 200;
 
   printf("交换前，a 的值： %d\n", a );
   printf("交换前，b 的值： %d\n", b );
 
   /* 调用函数来交换值
    * &a 表示指向 a 的指针，即变量 a 的地址 
    * &b 表示指向 b 的指针，即变量 b 的地址 
   */
   swap(&a, &b);
 
   printf("交换后，a 的值： %d\n", a );
   printf("交换后，b 的值： %d\n", b );
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
交换前，a 的值： 100
交换前，b 的值： 200
交换后，a 的值： 200
交换后，b 的值： 100
```

上面的实例表明了，与传值调用不同，引用调用在函数内改变了 a 和 b 的值，实际上也改变了函数外 a 和 b 的值。

或：（有些编译器中以下用法只支持cpp）

```c
#include <stdio.h>

void swap(int &x, int &y);
void swap(int &x, int &y)
{
    int temp;
    temp = x;
    x = y;
    y = temp;
}

int main( int argc, char *argv[] )
{
    int a = 5;
    int b = 10;
    swap(a, b); //调用交换函数
    printf("交换结果为 a = %d, b = %d\n",a,b);
    return 0;
}
```



### 内部与外部函数

####内部函数

如果一个函数只能被本文件中其他函数所调用，它称为内部函数。在定义内部函数时，在函数名和函数类型的前面加 static，即

```C
static 类型名 函数名 （形参表）
```

例如，函数的首行：

```C
static int max(int a,int b)
```

内部函数又称静态函数。使用内部函数，可以使函数的作用域只局限于所在文件。即使在不同的文件中有同名的内部函数，也互不干扰。提高了程序的可靠性。

####外部函数

如果在定义函数时，在函数的首部的最左端加关键字 extern，则此函数是外部函数，可供其它文件调用。

如函数首部可以为

```C
extern int max (int a,int b)
```

**C 语言规定，如果在定义函数时省略 extern，则默认为外部函数。**

在需要调用此函数的其他文件中，需要对此函数作声明（不要忘记，即使在本文件中调用一个函数，也要用函数原型来声明）。在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数。

####实例

以下实例通过多个文件的函数实现输入一串字符串，然后删除指定的字符：

file1.c(文件1)

```c
#include <stdio.h>

static void delete_string(char str[],char ch);
int main()
{
    extern void enter(char str[]); // 对函数的声明
    extern void print(char str[]); // 对函数的声明
    char c,str[100];
    enter(str);
    scanf("%c",&c);
    delete_string(str,c);
    print(str);
    return 0;
}

static void delete_string(char str[],char ch)//内部函数
{
    int i,j;
    for(i=j=0;str[i]!='\0';i++)
    if(str[i]!=ch)
    str[j++]=str[i];
    str[j]='\0';
}
```

file2.c(文件2)

```c
#include <stdio.h>

void enter(char str[100]) // 定义外部函数 enter
{
    fgets(str, 100, stdin); // 向字符数组输入字符串
}
```

file3.c(文件3)

```c
#include <stdio.h>

void print(char str[]) // 定义外部函数 print
{
    printf("%s\n",str);
}
```

输入字符串"abcdef"，给字符数组 str，在输入要删去的字符'd'。 运行结果:

```
$ gcc file1.c file2.c file3.c 
$ ./a.out
abcdef                   # 输入的字符串
d                        # 要删除的字符
abcef                    # 删除后的字符串
```



###关于 main 函数的参数

在有些很专业的书会看到如下代码

```
int main( int argc, char *argv[] )
```

上面的代码中 main 函数带了参数。

但是有时又会看见main函数没有参数，如下：

```
int main()
```

**那么 main 函数到底有没有参数，有没有参数会不会有什么影响？**

main 函数其实与我们写的函数没有什么区别，它也会有自己的参数。

argc 和 argv 是 main 函数的形式参数。

这两个形式参数的类型是系统规定的。如果 main 函数要带参数，就是这两个类型的参数；否则main函数就没有参数。

变量名称argc和argv是常规的名称，当然也可以换成其他名称。在传入参数后main函数收到参数后就会做自己的事。那么，实际参数是如何传递给main函数的argc和argv的呢？我们知道，C程序在编译和链接后，都生成一个exe文件，执行该exe文件时，可以直接执行；也可以在命令行下带参数执行，命令行执行的形式为：可执行文件名称 参数1 参数2 ... ... 参数n。可执行文件名称和参数、参数之间均使用空格隔开。

如果按照这种方法执行，命令行字符串将作为实际参数传递给main函数。具体为：

-  (1) 可执行文件名称和所有参数的个数之和传递给 argc；
-  (2) 可执行文件名称（包括路径名称）作为一个字符串，首地址被赋给 argv[0]，参数1也作为一个字符串，首地址被赋给 argv[1]，... ...依次类推。

###小细节

函数名和参数列表一起构成了函数签名。意味着可以出现参数列表不同但是函数名相同的函数。比如说定义两个函数：

```
void print()
{
    printf("hello world!");
}

void print(int nums)
{
    printf("%d\n",a);
}
```

这是合法的。

##C作用域规则

###局部和全局变量

在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用。下面是一个实例：

```c
#include <stdio.h>
 
/* 全局变量声明 */
int g = 20;
 
int main ()
{
  /* 局部变量声明 */
  int g = 10;
 
  printf ("value of g = %d\n",  g);
 
  return 0;
}
```

###形式参数

函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用。下面是一个实例：

```
#include <stdio.h>
 
/* 全局变量声明 */
int a = 20;
 
int main ()
{
  /* 在主函数中的局部变量声明 */
  int a = 10;
  int b = 20;
  int c = 0;
  int sum(int, int);
 
  printf ("value of a in main() = %d\n",  a);
  c = sum( a, b);
  printf ("value of c in main() = %d\n",  c);
 
  return 0;
}
 
/* 添加两个整数的函数 */
int sum(int a, int b)
{
    printf ("value of a in sum() = %d\n",  a);
    printf ("value of b in sum() = %d\n",  b);
 
    return a + b;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of a in main() = 10
value of a in sum() = 10
value of b in sum() = 20
value of c in main() = 30
```

**全局变量与局部变量在内存中的区别**：

- 全局变量保存在内存的全局存储区中，占用静态的存储单元；
- 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

### 局部和全局变量的初始化

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动对其初始化，如下所示：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

## C数组

### 1.传递数组给函数（一维）

如果想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，您也可以传递一个多维数组作为形式参数。

**方式1**：形式参数是一个指针

```c
void myFunc(int *param){

}
```

**方式2**：形式参数是一个已定义大小的数组

```c
void myFunction(int param[10])
{
}
```

**方式3**：形式参数是一个未定义大小的数组

```c
void myFunction(int param[])
{
}
```

实例：

```c
#include <stdio.h>
 
/* 函数声明 */
double getAverage(int arr[], int size);
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
 
   /* 传递一个指向数组的指针作为参数 */
   avg = getAverage( balance, 5 ) ;
 
   /* 输出返回值 */
   printf( "平均值是： %f ", avg );
    
   return 0;
}
 
double getAverage(int arr[], int size)
{
  int    i;
  double avg;
  double sum=0;
 
  for (i = 0; i < size; ++i)
  {
    sum += arr[i];
  }
 
  avg = sum / size;
 
  return avg;
}
```

就函数而言，数组的长度是无关紧要的，因为 C 不会对形式参数执行边界检查。

### 2.传递数组给函数（二维）

**方法1：**

第一维的长度可以不指定，但必须指定第二维的长度：

```c
void print_a(int a[][5], int n, int m)
```

**方法2：**

指向一个有5个元素一维数组的指针：

```c
void print_b(int (*a)[5], int n, int m)
```

**方法3：**

利用数组是顺序存储的特性,通过降维来访问原数组!

```c
void print_c(int *a, int n, int m)
```

实例：

```c
#include <stdio.h>
/*********************************
* 方法1: 第一维的长度可以不指定
*        但必须指定第二维的长度
*********************************/ 
void print_a(int a[][5], int n, int m){ 
    int i, j;
    for(i = 0; i < n; i++) {
        for(j = 0; j < m; j++) 
            printf("%d ", a[i][j]); 
        printf("\n"); 
    } 
} 

/***************************************** 
* 方法2: 指向一个有5个元素一维数组的指针
*****************************************/ 
void print_b(int (*a)[5], int n, int m) { 
    int i, j;
    for(i = 0; i < n; i++) { 
        for(j = 0; j < m; j++) 
            printf("%d ", a[i][j]);
        printf("\n"); 
    } 
}

/*********************************** 
* 方法3: 利用数组是顺序存储的特性, 
*       通过降维来访问原数组!
***********************************/ 
void print_c(int *a, int n, int m) { 
    int i, j; 
    for(i = 0; i < n; i++) { 
        for(j = 0; j < m; j++) 
            printf("%d ", *(a + i*m + j));
        printf("\n"); 
    } 
}
int main(void) 
{ 
    int a[5][5] = {{1, 2}, {3, 4, 5}, {6}, {7}, {0, 8}}; 

    printf("\n方法1:\n");   
    print_a(a, 5, 5); 

    printf("\n方法2:\n");   
    print_b(a, 5, 5);   

    printf("\n方法3:\n");   
    print_c(&a[0][0], 5, 5); 

//    getch(); 
    return 0; 
}
```

**易错点：**

如果我们想将二维数组作为实参传递给某个函数，如下代码是有问题的: 

```
double * MatrixMultiple(double a[][], double b[][]);
```

原因可以简单理解为：编译器并没有那么高级，在二维以上的数组一定要规定一个最高维数:

```
double * MatrixMultiple(double a[][2], double b[][3]);  /* 这才是正确的 */
```

###3.从函数返回数组

C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：

```c
int * myFunction()
{
}
```

另外，C **不支持在函数外返回局部变量的地址**，除非定义局部变量为 **static** 变量。

例：生成10个随机数，并使用数组返回它们。

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
 
/* 要生成和返回随机数的函数 */
int * getRandom( )
{
  static int  r[10];
  int i;
 
  /* 设置种子 */
  srand( (unsigned)time( NULL ) );
  for ( i = 0; i < 10; ++i)
  {
     r[i] = rand();
     printf( "r[%d] = %d\n", i, r[i]);
 
  }
 
  return r;
}
 
/* 要调用上面定义函数的主函数 */
int main ()
{
   /* 一个指向整数的指针 */
   int *p;
   int i;
 
   p = getRandom();
   for ( i = 0; i < 10; i++ )
   {
       printf( "*(p + %d) : %d\n", i, *(p + i));//这里用p[i]也可以
   }
 
   return 0;
}
```

### 4.指针与数组

数组名是一个指向数组中第一个元素的常量指针。因此，在下面的声明中：

```
double balance[50];
```

**balance** 是一个指向 &balance[0] 的指针，即数组 balance 的第一个元素的地址。因此，下面的程序片段把 **p** 赋值为 **balance** 的第一个元素的地址：

```
double *p;
double balance[10];

p = balance;
```

使用数组名作为常量指针是合法的，反之亦然。因此，*(balance + 4) 是一种访问 balance[4] 数据的合法方式。

一旦您把第一个元素的地址存储在 p 中，您就可以使用 \*p、\*(p+1)、\*(p+2) 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：

```c
#include <stdio.h>
 
int main ()
{
   /* 带有 5 个元素的整型数组 */
   double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};
   double *p;
   int i;
 
   p = balance;
 
   /* 输出数组中每个元素的值 */
   printf( "使用指针的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(p + %d) : %f\n",  i, *(p + i) );
   }
 
   printf( "使用 balance 作为地址的数组值\n");
   for ( i = 0; i < 5; i++ )
   {
       printf("*(balance + %d) : %f\n",  i, *(balance + i) );
   }
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
使用指针的数组值
*(p + 0) : 1000.000000
*(p + 1) : 2.000000
*(p + 2) : 3.400000
*(p + 3) : 17.000000
*(p + 4) : 50.000000
使用 balance 作为地址的数组值
*(balance + 0) : 1000.000000
*(balance + 1) : 2.000000
*(balance + 2) : 3.400000
*(balance + 3) : 17.000000
*(balance + 4) : 50.000000
```

###5.字符串指针与字符数组的区别

```
char *str="Hello";
char arrgs[]="Hello";
```

字符数组:

```
char *p=(char*)&arrgs 相当于 char *p = arrgs ;
char *p=(char*)(&(arrgs[0])) 相当于 char *p = &arrgs 相当于 char *p = arrgs;
```

字符串指针:

```
char *p=(char*)&str 并不等同于char *p=str; 因为str==str[0] =='H'
```

得出结论字符数组的 首地址可以用 arrgs ，&arrgs,来表示并且它们相等，

但是指针&str和str是不同的，所以当遇到字符串指针时候要注意处理方式！！！

### 6.数组元素个数

在我们没有明确数组的元素个数时，在程序中想知道数组单元个数可以使用 **sizeof(a)/sizeof(a[0])**, **sizeof(a)**是得到数组 a 的大小，**sizeof(a[0])** 是得到数组 a 中单个元素的大小（因此可以不必要是a[0],a[i]都行）。

```c
#include<stdio.h>

int main(int argc,char *grgv[])
{
    int a[]={1,2,3,4,5};
    int b;
    b=sizeof(a)/sizeof(a[0]);
    printf("数组元素个数为：%d",b);
    return 0; 
}
```

注意：这种表达式不能在自定义函数中“形参是数组”的情况下使用，只能在定义数组的作用域内算出数组长度然后传到自定义函数中使用。

### 数组与指针示例补充

```C
#include <stdio.h>

int main()
{
    int a[2] = {1,2};
    printf("a      = %d\n",a[0]);
    printf("*(a+0) = %d\n",*(a + 0));
    printf("a[1]   = %d\n",a[1]);
    printf("*a     = %d\n",*a);
    printf("*(a+1) = %d\n",*(a + 1));
    printf("\n");
    printf("a    的地址：%p\n",a);
    printf("(a+0)的地址：%p\n",(a + 0));
    printf("(a+1)的地址：%p\n",(a + 1));
    // %p 读入一个指针
    printf("\n");
    return 0;
}
```

输出结果：

```
a      = 1
*(a+0) = 1
a[1]   = 2
*a     = 1
*(a+1) = 2

a    的地址：0x7ffe9e227634
(a+0)的地址：0x7ffe9e227634
(a+1)的地址：0x7ffe9e227638
```

事实上 **a[0] 、a[1]...a[i]** 代表的都是值，**a、(a+0)、(a+1)、(a+i)** 代表的是地址；另外这里的 **a** 代表整个数组的首地址，相当于 **a[0]** 的地址，而这里 **(a+1)** 就代表的是 **a[0+1]** 的地址。

正如文章中提到的：所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素，即是说 **(a+i)** 就代表的是 **a[0+i]** 的地址。

##C enum(枚举) 此处不做深究。

枚举是 C 语言中的一种基本数据类型，它可以让数据更简洁，更易读。

枚举语法定义格式为：

```
enum　枚举名　{枚举元素1,枚举元素2,……};
```

接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 #define 来为每个整数定义一个别名：

\#define MON  1 #define TUE  2 #define WED  3 #define THU  4 #define FRI  5 #define SAT  6 #define SUN  7

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

这样看起来是不是更简洁了。

**注意：**第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。

> 可以在定义枚举类型时改变枚举元素的值：
>
> ```
> enum season {spring, summer=3, autumn, winter};
> ```
>
> 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

####枚举变量的定义

前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。

我们可以通过以下三种方式来定义枚举变量

**1、先定义枚举类型，再定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**实例**

```c
#include<stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main()
{
    enum DAY day;
    day = WED;
    printf("%d",day);
    return 0;
}
```



以上实例输出结果为：

```
3
```

在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。

不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。

以下实例使用 for 来遍历枚举的元素：（这些元素必须是连续的）

**实例**

```c
#include<stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
int main()
{
    // 遍历枚举元素
    for (day = MON; day <= SUN; day++) {
        printf("枚举元素：%d \n", day);
    }
}
```

以上实例输出结果为：

```
枚举元素：1 
枚举元素：2 
枚举元素：3 
枚举元素：4 
枚举元素：5 
枚举元素：6 
枚举元素：7
```

以下枚举类型不连续，这种枚举无法遍历。

```
enum
{
    ENUM_0,
    ENUM_10 = 10,
    ENUM_11
};
```

枚举在 switch 中的使用：

**实例**

```
#include <stdio.h>
#include <stdlib.h>
int main()
{
 
    enum color { red=1, green, blue };
 
    enum  color favorite_color;
 
    /* ask user to choose color */
    printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");
    scanf("%d", &favorite_color);
 
    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf("你喜欢的颜色是红色");
        break;
    case green:
        printf("你喜欢的颜色是绿色");
        break;
    case blue:
        printf("你喜欢的颜色是蓝色");
        break;
    default:
        printf("你没有选择你喜欢的颜色");
    }
 
    return 0;
}
```

以上实例输出结果为：

```
请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1
你喜欢的颜色是红色
```

### 将整数转换为枚举

以下实例将整数转换为枚举：

**实例**

```c
#include <stdio.h>
#include <stdlib.h>
 
int main()
{
 
    enum day
    {
        saturday,
        sunday,
        monday,
        tuesday,
        wednesday,
        thursday,
        friday
    } workday;
 
    int a = 1;
    enum day weekend;
    weekend = ( enum day ) a;  //类型转换
    //weekend = a; //错误
    printf("weekend:%d",weekend);
    return 0;
}
```

以上实例输出结果为：

```
weekend:1
```

## C指针

###1.基本概念回顾

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。

```c
#include <stdio.h>

int main ()
{
    int var = 20;   /* 实际变量的声明 此时的 VAR 这个变量是存在某个地址的，地址对应某个内存单元，该单元中存储了数据20 */
    int *ip;         /* 指针变量的声明 定义了一个指针 即一个内存单元的地址变量 */

    ip = &var;      /* 在指针变量中存储 var 的地址 就是将地址值赋值给指针这个变量*/

    /* 在指针变量中存储的地址 利用&符号直接输出了var所存储的数据的内存单元的地址*/
    printf("Address of var variable: %p\n", &var );
    
    /* 在指针变量中存储的地址 ip代表的是这个赋值到的地址的值 所以输出的是地址值 */
    printf("Address stored in ip variable: %p\n", ip );
    
    /* 使用指针访问值 *ip代表的是定义到这个内存单元之后，内存单元中所存储的数据的值也就是将20赋值给var中20这个值 */
    printf("Value of *ip variable: %d\n", *ip );

    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Address of var variable: bffd8b3c
Address stored in ip variable: bffd8b3c
Value of *ip variable: 20
```

### 2.NULL指针

```c
#include <stdio.h>
 
int main ()
{
   int  *ptr = NULL;
 
   printf("ptr 的地址是 %p\n", ptr  );
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
ptr 的地址是 0x0
```

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。

### 3.复杂指针详解

从变量名处起, 根据运算符优先级结合, 一步一步分析。

先从简单的类型开始慢慢分析吧:

-  **int p;** -- 这是一个普通的整型变量
-  **int \*p;** -- 首先从 p 处开始,先与*结合,所以说明 p 是一个指针, 然后再与 int 结合, 说明指针所指向的内容的类型为 int 型。所以 p 是一个返回整型数据的指针。
-  **int p[3]** -- 首先从 p 处开始,先与[] 结合,说明 p 是一个数组, 然后与 int 结合, 说明数组里的元素是整型的, 所以 p 是一个由整型数据组成的数组。
-  **int \*p[3];** -- 首先从 p 处开始, 先与 [] 结合, 因为其优先级比 * 高,所以 p 是一个数组, 然后再与 * 结合, 说明数组里的元素是指针类型, 然后再与 int 结合, 说明指针所指向的内容的类型是整型的, 所以 p 是一个由返回整型数据的指针所组成的数组。
-  **int (\*p)[3];** -- 首先从 p 处开始, 先与 * 结合,说明 p 是一个指针然后再与 [] 结合(与"()"这步可以忽略,只是为了改变优先级), 说明指针所指向的内容是一个数组, 然后再与int 结合, 说明数组里的元素是整型的。所以 p 是一个指向由整型数据组成的数组的指针。
-  **int \**p;** -- 首先从 p 开始, 先与 * 结合, 说是 p 是一个指针, 然后再与 * 结合, 说明指针所指向的元素是指针, 然后再与 int 结合, 说明该指针所指向的元素是整型数据。由于二级指针以及更高级的指针极少用在复杂的类型中, 所以后面更复杂的类型我们就不考虑多级指针了, 最多只考虑一级指针。
-  **int p(int);** -- 从 p 处起,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里分析, 说明该函数有一个整型变量的参数, 然后再与外面的 int 结合, 说明函数的返回值是一个整型数据。
-  **int (\*p)(int);** -- 从 p 处开始, 先与指针结合, 说明 p 是一个指针, 然后与()结合, 说明指针指向的是一个函数, 然后再与()里的 int 结合, 说明函数有一个int 型的参数, 再与最外层的 int 结合, 说明函数的返回类型是整型, 所以 p 是一个指向有一个整型参数且返回类型为整型的函数的指针。
-  **int \*(\*p(int))[3];** -- 可以先跳过, 不看这个类型, 过于复杂从 p 开始,先与 () 结合, 说明 p 是一个函数, 然后进入 () 里面, 与 int 结合, 说明函数有一个整型变量参数, 然后再与外面的 * 结合, 说明函数返回的是一个指针, 然后到最外面一层, 先与[]结合, 说明返回的指针指向的是一个数组, 然后再与 * 结合, 说明数组里的元素是指针, 然后再与 int 结合, 说明指针指向的内容是整型数据。所以 p 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数。

####3.1详述指针

#####3.1.1指针的类型

<span style="color:red;background-color:#97e1aa">注意上例中**int \*p[3];**对应的p并不是单独的指针，而是一个由指针变量构成的数组，相当于一个两层的指针，在以下讨论中不做考虑。同样地，在复杂的类型中，(\*ptr)的形式对应的ptr才是单独的指针变量，其他例如*ptr[3]中的ptr是指针变量构成的数组，\*ptr(int)中的ptr则是有整型参数且返回类型为指针的一个函数。</span>

从语法的角度看，你只要把**指针声明语句里的指针名字去掉**，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：

- 1、**int\*ptr;** : 指针的类型是 **int\***
- 2、**char\*ptr;** : 指针的类型是 **char\***
- 3、**int\**ptr;** : 指针的类型是 **int\****
- 4、**int(\*ptr)[3];** : 指针的类型是 **int(\*)[3]**
- 5、**int\*(\*ptr)[4];** : 指针的类型是 **int\*(\*)[4]**

#####3.1.2指针所指向的类型

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

从语法上看，你只须**把指针声明语句中的指针名字和名字左边的指针声明符\*去掉**，剩下的就是指针所指向的类型。例如：

- 1、**int\*ptr;** : 指针所指向的类型是 **int**
- 2、**char\*ptr;** : 指针所指向的的类型是 **char**
- 3、**int\**ptr;** : 指针所指向的的类型是 **int\***
- 4、**int(\*ptr)[3];** : 指针所指向的的类型是 **int()[3]**
- 5、**int\*(\*ptr)[4];** : 指针所指向的的类型是 **int\*()[4]**

**指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。**

#####3.1.3指针的值

指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32 位程序里，所有类型的**指针的值**都是一个32 位整数，因为32 位程序里内存地址全都是32位长。**指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区**。

<span style="background-color:yellow;color:red">以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。</span>

今后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）

#####3.1.4指针本身所占据的内存区

指针本身占了多大的内存？只要用函数sizeof(指针的类型)测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度。<span style="color:red; background-color:yellow">无论是int\*型还是char\*型指针都占4个字节！！！</span>指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。

#### 3.2指针的算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：

```c
char a[20];
int *ptr=(int *)a; //注意，这里给ptr赋值时对a强制类型转换并不会改变 a 本身的类型
ptr++;
```

在上例中，指针 ptr 的类型是 int*,它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第 3 句中，指针 ptr 被加了 1，编译器是这样处理的：**它把指针 ptr 的值加上了 sizeof(int)**，在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，<span style="color:red;background-color:yellow">原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。</span>

我们可以用一个指针和一个循环来遍历一个数组，看例子：

```c
int array[20]={0};
int *ptr=array;
for(i=0;i<20;i++)
{
    (*ptr)++;
    ptr++；
}
```

这个例子将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr 加 1 个单元，所以每次循环都能访问数组的下一个单元。

再看例子：

```c
char a[20]="You_are_a_girl";
int *ptr=(int *)a;
ptr+=5;
```

在这个例子中，ptr 被加上了 5，编译器是这样处理的：将指针 ptr 的值加上 5 乘 sizeof(int)，在 32 位程序中就是加上了 5 乘 4=20。由于地址的单位是字节，故现在的 ptr 所指向的地址比起加 5 后的 ptr 所指向的地址来说，向高地址方向移动了 20 个字节。

在这个例子中，没加 5 前的 ptr 指向数组 a 的第 0 号单元开始的四个字节，加 5 后，ptr 已经指向了数组 a 的合法范围之外了。**虽然这种情况在应用上会出问题，但在语法上却是可以的。**这也体现出了指针的灵活性。如果上例中，ptr 是被减去 5，那么处理过程大同小异，只不过 ptr 的值是被减去 5 乘 sizeof(int)，新的 ptr 指向的地址将比原来的 ptr 所指向的地址向低地址方向移动了 20 个字节。

练习题：

```c
#include<stdio.h>
int main()
{
    char a[20]=" You_are_a_girl";
    char *p=a;
    char **ptr=&p;
    //printf("p=%d\n",p);
    //printf("ptr=%d\n",ptr);
    //printf("*ptr=%d\n",*ptr);
    printf("**ptr=%c\n",**ptr);
    ptr++;
    //printf("ptr=%d\n",ptr);
    //printf("*ptr=%d\n",*ptr);
    printf("**ptr=%c\n",**ptr);
}
```

**误区一、输出答案为 Y 和 o**

误解: ptr 是一个 char 的二级指针, 当执行 ptr++; 时,会使指针加一个 sizeof(char), 所以输出如上结果,这个可能只是少部分人的结果。

**误区二、输出答案为 Y 和 a  **

误解: ptr 指向的是一个 char * 类型, 当执行 ptr++; 时,会使指针加一个 sizeof(char *) (有可能会有人认为这个值为 1, 那就会得到误区一的答案, 这个值应该是 4, 参考前面内容), 即 &p+4; 那进行一次取值运算不就指向数组中的第五个元素了吗? 那输出的结果不就是数组中第五个元素了吗?答案是否定的。

**正解:** ptr 的类型是 char **, 指向的类型是一个 char * 类型, 该指向的地址就是 p 的地址 (&p), 当执行 ptr++; 时, 会使指针加一个 sizeof(char*), 即 &p+4; 那 *(&p+4) 指向哪呢, 这个你去问上帝吧, 或者他会告诉你在哪? 所以最后的输出会是一个随机的值, 或许是一个非法操作。

**此类问题总结：**

一个指针 ptrold 加(减)一个整数 n 后，结果是一个新的指针 ptrnew，ptrnew 的类型和 ptrold 的类型相同，ptrnew 所指向的类型和 ptrold 所指向的类型也相同。**ptrnew 的值将比 ptrold 的值增加(减少)了 n 乘 sizeof(ptrold 所指向的类型)个字节。**就是说，**ptrnew 所指向的内存区将比ptrold 所指向的内存区向高(低)地址方向移动了 n 乘 sizeof(ptrold 所指向的类型)个字节。**

指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面。

#### 3.3运算符&，*

这里 **&** 是取地址运算符，***** 是间接运算符。

**&a** 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。

***p** 的运算结果就五花八门了。总之 *p 的结果是p 所指向的东西，这个东西有这些特点：**它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址**。

```c
int a=12; int b; int *p; int **ptr;
p=&a; //&a 的结果是一个指针，类型是int*，指向的类型是
//int，指向的地址是a 的地址。
*p=24; //*p 的结果，在这里它的类型是int，它所占用的地址是
//p 所指向的地址，显然，*p 就是变量a。
ptr=&p; //&p 的结果是个指针，该指针的类型是p 的类型加个*，
//在这里是int **。该指针所指向的类型是p 的类型，这
//里是int*。该指针所指向的地址就是指针p 自己的地址。
*ptr=&b; //*ptr 是个指针，&b 的结果也是个指针，且这两个指针
//的类型和所指向的类型都为int型，是一样的。所以用&b 来给*ptr 赋
//值就是毫无问题的了。
**ptr=34; //*ptr 的结果是ptr 所指向的东西，在这里是一个指针，
//对这个指针再做一次*运算，结果是一个int 类型的变量b。
```

#### 3.4指针表达式

一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。

下面是一些指针表达式的例子：

实例:

```c
int a,b;
int array[10];
int *pa;
pa=&a; //&a 是一个指针表达式。
int **ptr=&pa; //&pa 也是一个指针表达式。
*ptr=&b; //*ptr 和&b 都是指针表达式。
pa=array;
pa++; //这也是指针表达式。
```

```c
char *arr[20];
char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式
char *str;
str=*parr; //*parr 是指针表达式
str=*(parr+1); //*(parr+1)是指针表达式
str=*(parr+2); //*(parr+2)是指针表达式
```

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。

好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&a 不是一个左值，因为它还没有占据明确的内存。*ptr 是一个左值，因为 *ptr 这个指针已经占据了内存，其实 *ptr 就是指针 pa，既然 pa 已经在内存中有了自己的位置，那么 *ptr 当然也有了自己的位置。

#### 3.5数组和指针的关系

数组的数组名其实可以看作一个指针。看下例：

```c
int array[10]={0,1,2,3,4,5,6,7,8,9},value;
value=array[0]; //也可写成：value=*array;
value=array[3]; //也可写成：value=*(array+3);
value=array[4]; //也可写成：value=*(array+4);
```

上例中，一般而言数组名 array 代表数组本身，类型是 int[10]，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 int* 所指向的类型是数组单元的类型即 int。因此 *array 等于 0 就一点也不奇怪了。同理，array+3 是一个指向数组第 3 个单元的指针，所以 ***(array+3)** 等于 3。其它依此类推。

```c
char *str[3]={
    "Hello,thisisasample!",
    "Hi,goodmorning.",
    "Helloworld"
};
char s[80]；
strcpy(s,str[0]); //也可写成strcpy(s,*str);
strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));
strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));
```

<span style="color:red; background-color:yellow">这个作为一道习题，考察前面的所有内容。请自行调整以下空白处答案标签css的字体颜色以查看答案。</span>

问题1:str是什么？

<span style="color:white">str是一个数组，数组中的每个元素都是指针变量。与此同时，该数组也等于后面的三个字符串构成的数组。</span>

问题2:str[0]？

<span style="color:white">str[0]既是字符串"Hello,thisisasample"，又是一个指针。又易知str[0]是数组"Hello,thisisasample"首元素的地址，因此str[0]指向首字母H。注意：printf用%p会输出指针形式（一个地址），用%s会输出字符串形式。</span>

问题3:*str?

<span style="color:white">数组名str是数组首元素的地址，也就是"Hello,thisisasample"的地址。因此*str就是这个字符串。另外str[0]也是一个指针，指向第一个字符串的首字母H。本质上，\*str==str[0]</span>

问题4:*str[0]?

<span style="color:white">字母H，详情见第二问。</span>

问题5:str的类型？它指向的类型又是什么？

<span style="color:white">char\**      char\*</span>

问题6:str+1的类型？它指向的类型？它指向的是什么东西？

<span style="color:white">str+1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char\**，它指向的类型是 char\*。</span>

问题7:*(str+1)的类型？它指向的类型？它指向的是什么东西？

<span style="color:white">*(str+1) 也是一个指针，它的类型是 char\*，它所指向的类型是 char，它指向 "Hi,goodmorning." 的第二个字符 'i'。</span>

----------------------------分割线-------------------------

#####总结：

声明了一个数组 **TYPE array[n]**，则数组名称 array 就有了两重含义：

- 第一，它代表整个数组，它的类型是 **TYPE[n]**；
- 第二，它是一个常量指针，该指针的类型是 **TYPE\***，该指针指向的类型是 **TYPE**，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时 sizeof 函数测出的是整个数组的大小。

在表达式 *array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。<span style="color:red; background-color:yellow">**sizeof(\*array)** 测出的是数组单元的大小。</span>

表达式 array+n（其中n=0，1，2，.....）中，array 扮演的是指针，故array+n 的结果是一个指针，它的类型是 **TYPE \***，它指向的类型是 TYPE，它指向数组第 n 号单元。故sizeof(array+n)测出的是指针类型的大小。在 32 位程序中结果是 4。

最后一个示例：

```c
int array[10];
int (*ptr)[10];
ptr=&array;
```

上例中 ptr 是一个指针，它的类型是 **int(\*)[10]**，他指向的类型是 int[10] ，我们用整个数组的首地址来初始化它。在语句 ptr=&array中，array 代表数组本身。

注意两点：

（1）&array[0]和array完全一样，他们的值也和&array一样，但是后者的类型是int(*)[10]，和前两者的int\*不同。这会导致运算上产生区别：&array+1是向后移动10\*4个单位，array+1是向后移动4个单位。

（2）不能直接进行`array++;`这一表达式。因为C编译器要拿着a去析构内存，为了避免你把a的指向改变。

#### 3.6指针和结构体的关系

可以声明一个指向结构类型对象的指针。实例：

```c
struct MyStruct
{
    int a;
    int b;
    int c;
};
struct MyStruct ss={20,30,40};
//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。
struct MyStruct *ptr=&ss;
//声明了一个指向结构对象ss 的指针。它的类型是
//MyStruct *,它指向的类型是MyStruct。
int *pstr=(int*)&ss;
//声明了一个指向结构对象ss 的指针。但是pstr 和
//它被指向的类型与ptr 是不同的，分别是int *和int
```

怎样通过指针 ptr 来访问 ss 的三个成员变量？

```c
ptr->a; //指向运算符，或者可以用(*ptr).a,建议使用前者
ptr->b;
ptr->c;
```

怎样通过指针 pstr 来访问 ss 的三个成员变量？

```c
*pstr； //访问了ss 的成员a。
*(pstr+1); //访问了ss 的成员b。
*(pstr+2) //访问了ss 的成员c。
```

从格式上看，这与通过指针访问数组成员的格式一样。然而，数组的单元都是被存放在连续的存储区域内的。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个"填充字节"，这就导致各个成员之间可能会有若干个字节的空隙。

注意，在上例中，**即使 *pstr 访问到了结构对象 ss 的第一个成员变量 a，也不能保证 *(pstr+1) 就一定能访问到结构成员 b**。因为成员 a 和成员 b 之间可能会有若干填充字节，说不定 *(pstr+1) 就正好访问到了这些填充字节。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，这倒是个不错的方法。

指针访问结构成员的正确方法应该是使用指针 ptr 的方法。

#### 3.7 指针和函数的关系

#####3.7.1函数指针（指向函数的指针）

<span style="color:red;background-color:yellow">一个函数在编译之后，会占据一部分内存，而它的函数名，就是这段函数的首地址。</span>

可以把一个指针声明成为一个指向函数的指针。

C语言规定函数名会被转换为指向这个函数的指针，除非这个函数名作为 & 操作符或sizeof操作符的操作数(注意：函数名用于sizeof的操作数是非法的)。**也就是说f = test;中test被自动转换为&test**，而f = &test;中已经显示使用了&test，所以test就不会再发生转换了。因此直接引用函数名等效于在函数名上应用 & 运算符，两种方法都会得到指向该函数的指针。

指向函数的指针必须初始化，或者具有0值，才能在函数调用中使用。

与数组一样，（1）禁止对指向函数的指针进行自增运算++ （2）禁止对函数名赋值，函数名也不能用于进行算术运算。

示例1:

```c
int fun1(int,int);
int fun1(int a, int b)
{
  return a+b;
}
int main(){
  int (*pfun1)(int,int);
  pfun1=fun1;//这里&fun1和fun1的值和类型都一样，用哪个无所谓
  int a=(*pfun1)(5,7); //通过函数指针调用函数。
}
```

示例2:

```c
#include <stdio.h>
#include <stdlib.h>
int Max(int x, int y)  //定义Max函数
{
 int z;
 if (x > y) {
  z = x;
 }
 else {
  z = y;
 }
 return z;
}
int main() {
 //定义一个函数指针
 int(*p)(int, int);  
 int a, b, c;
 //把函数Max赋给指针变量p, 使p指向Max函数
 p = Max; 
 printf("please enter a and b:");
 scanf("%d%d", &a, &b);
 //通过函数指针调用Max函数
 c = (*p)(a, b);  
 printf("a = %d\nb = %d\nmax = %d\n", a, b, c);
 system("pause");
 return 0;
}

```

示例2:

```C
#include <stdio.h>

 

void test( )

{

    printf("test called!/n");

}

 

int main( )

{

    void (*f) ( );

    f = test; 

    f ( );

    (*f)( );

    //test++;              // error，标准禁止对指向函数的指针进行自增运算

          //test = test + 2;        // error，不能对函数名赋值，函数名也不能用于进行算术运算

          printf("%p/n", test);

          printf("%p/n", &test);

          printf("%p/n", *test);

  return 0;

}
```

运行结果为：

```
test called!

test called!

004013EE

004013EE

004013EE
```

这里的玄学就是*test为什么能和上面两个之前介绍过的输出一样的值。

首先来看函数名`test`，是一个符号用来标识一个函数的入口地址，在使用中函数名会被转换为指向这个函数的指针，指针的值就是函数的入口地址，`&test`在前面已经说了：显示获取函数的地址。`*test`可以认为由于test已经被转换成了函数指针*,* 指向这个函数，所以\*test就是取这个指针所指向的函数名，而又根据函数名会被转换指向该函数的指针的规则，这个函数也转变成了一个指针，所以\*test最终也是一个指向函数test的指针。也就是说:` *test --> *(&test) --> test --> &test`。

<span style="color:red; background-color:yellow">上述关系十分重要！</span>

为了更加明确，把示例1做补充：

```c
#include <stdio.h>
int fun1(int,int);
int fun1(int a, int b)
{
    return a+b;
}
/* 要调用上面定义函数的主函数 */
int main ()
{
    int (*pfun1)(int,int);
    pfun1=fun1;//这里&fun1和fun1的值和类型都一样，用哪个无所谓
    int a=(*pfun1)(5,7); //通过函数指针调用函数。
    printf("%d\n",a);
  	int e = fun1(5,7);
  	printf("%d\n",d)
    int b = (&fun1)(5,7);
    printf("%d\n",b);
    int c = (*fun1)(5,7);
    printf("%d",c);
    return 0;
}
//根据关系  *fun1==*&fun1==fun1==&fun1  可知，以上的运行结果会得到4个5+7。
//因此在3.7.4中，action[2]()就相当于这里的(&fun1(5,7))，这点务必搞清楚。
```



##### 3.7.2指针函数（返回值为指针的函数）

所谓指针函数，就是返回指针的函数。在前面笔记中“从函数返回数组”中已经介绍。

C语言的库函数中有很多都是指针函数，比如字符串处理函数，下面给出一些函数原型：

```c
char *strcat( char *dest, const char *src );

char *strcpy( char *dest, const char *src );

char *strchr( const char *s, int c );

char *strstr( const char *src, const char *sub );
```

#####3.7.3两者混用（不常用）

注意函数的返回值不仅仅局限于指向变量的指针，也可以是指向函数的指针。

首先来看这个声明：`*int (*function(int)) (double*, char);`要了解此声明的含义，首先来看function(int)，将function声明为一个函数，它带有一个int型的形式参数，这个函数的返回值为一个指针，正是函数指针int (\*) (double\*, char);这个指针指向一个函数，此函数返回int型并带有两个分别是double*型和char型的形参。

如果使用typedef可以将这个声明简化：（没看懂。。。。之后的结构体再补充）

```c
typedef  int (*ptf) (double*, char);

ptf  function( int );
```

另一个例子：`void (*signal (int sig, void (*func) (int siga)) ) ( int siga );`

现在要分析的是signal，因为紧邻signal的是优先级最高的括号，首先与括号结合，所以signal为一个函数，括号内为signal的两个形参，一个为int型，一个为指向函数的指针。接下来从向左看，*表示指向某对象的指针，它所处的位置表明它是signal的返回值类型，现在可以把已经分析过的signal整体去掉，得到void (\*) ( int siga )。又是一个函数指针，这个指针与signal形参表中的第二个参数类型一样，都是指向接受一个int型形参且不返回任何值的函数的指针。

用*typedef*可以将这个声明简化：

```c
typedef int (*p_sig) (double*, char);

p_sig signal(int sig, p_sig func);
```

这个*signal*函数是*C*语言的库函数，在*signal.h*中定义，用来处理系统中产生的信号。

##### 3.7.4函数指针数组

假设现在有一个文件处理程序，通过一个菜单按钮来选择相应的操作*(*打开文件，读文件，写文件，关闭文件*)*。这些操作都实现为函数且类型相同，分别为：

```c
void open();
void read();
void write();
void close();
```

现在定义一个函数指针类型的别名PF：`typedef void (*PF) ( );`  

把以上4种操作取地址放入一个数组中，得到：

```c
PF file_options[] = {

                 &open,

                 &read,

                 &write,

                 &close

};
```

如果不使用*typedef*，那么分析起来就会比较复杂，结果是`void (*file_options[ ]) ( );`

这个数组中的元素都是指向不接受参数且不返回任何值的函数的指针，因此这是一个函数指针数组。接下来，定义一个函数指针类型的指针action并初始化为函数指针数组的第一个元素：`PF* action = file_options;`，如果不好理解，可以类比一下

`int ia[4] = {0, 1, 2, 3}; int *ip = ia;`，

这里PF相当于int，这样应该比较好懂了。

复习：

```c
int ia[4] = {0, 1, 2, 3};
int *ip = ia; //ia就是&ia[0]，因此ip指向ia[0]。与此同时ip[1]的含义又和*(ip+1)一样。
    printf("%p\n",ip);
    printf("%p\n",ip+1);
    printf("%d\n",ip[1]);
    printf("%d\n",*(ip+1));

/*输出结果
0x7ffee4cca9b0
0x7ffee4cca9b4
1
1
*/
```

通过对指针action进行下标操作可以调用数组中的任一操作，如：`action[2]( )`会调用write操作，以此类推。在实际中，指针action可以和鼠标或者其他GUI对象相关联，以达到相应的目的。

#####3.7.5函数与指针的复杂声明（不做要求，一般用typedef代替它）

只举一个例子：`int *(*(*fp)(int)) [10]; `

阅读步骤：

1．从未定义的变量名开始阅读 -------------------------------------------- fp

2．往右看，什么也没有，遇到了)，因此往左看，遇到一个* ------ 一个指向某对象的指针

3．跳出括号，遇到了(int) ----------------------------------- 一个带一个int参数的函数

4．向左看，发现一个* --------------------------------------- （函数）返回一个指向某对象的指针

5．跳出括号，向右看，遇到[10] ------------------------------ 一个10元素的数组

6．向左看，发现一个* --------------------------------------- 一个指向某对象指针

7．向左看，发现int ----------------------------------------- int类型

所以fp是指向函数的指针（函数指针）,该函数返回一个指向数组的指针，此数组有10个int*型的元素。

```c
int *(*(*fp)(int)) [10];
(*fp)(int)是一个指向函数的指针ptr
*(*fp)(int)相当于一个指针ptr1（指针函数的返回值）
最后剩下int *ptr1[10]，可以理解。
```

#### 3.8指针的强制类型转换

当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。

```c
float f=12.3;
float *fptr=&f;
int *p;
```

在上面的例子中，假如我们想让指针 p 指向实数 f，应该怎么办？

`p=&f;`是错的。因为指针 p 的类型是 int *，它指向的类型是 int。表达式 &f 的结果是一个指针，指针的类型是 float *,它指向的类型是 float。

两者不一致，直接赋值的方法是不行的。对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致。为了实现我们的目的，需要进行"强制类型转换"：`p=(int*)&f;`

如果有一个指针 p，我们需要把它的类型和所指向的类型改为 **TYPE \*TYPE**，那么语法格式是：**(TYPE \*)p**

这样强制类型转换的结果是一个新指针，该新指针的类型是 **TYPE \***，它指向的类型是 **TYPE**，它指向的地址就是原指针指向的地址。<span style="color:red;background-color:yellow"> 而原来的指针p 的一切属性都没有被修改。（这点前面强调过，再次重点强调）</span>

一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换:

```c
void fun(char*);
int a=125,b;
fun((char*)&a);
void fun(char*s)
{
    char c;
    c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;
    c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;
}
/*
**注意这是一个 32 位程序，故 int 类型占了四个字节，char 类型占一个字节。函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒。
**在函数调用语句中，实参 &a 的结果是一个指针，它的类型是 int *，它指向的类型是 int。形参这个指针的类型是 char *，它指向的类型是 char。这样，在实参和形参的结合过程中，我们必须进行一次从 int * 类型到 char * 类型的转换。
*/
```

把一个整数当作指针的值直接赋给指针：

```c
unsigned int a;
TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。
a=N //N 必须代表一个合法的地址；
ptr=(TYPE*)a； 
```

#### 3.9指针的安全问题

看下面的例子：

```c
char s='a';
int *ptr;
ptr=(int *)&s;
*ptr=1298;
```

指针 ptr 是一个 int * 类型的指针，它指向的类型是 int。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。



让我们再来看一例：

```c
char a;
int *ptr=&a;
ptr++;
*ptr=115;
```

该例子完全可以通过编译，并能执行。但是看到没有？第 3 句对指针 ptr 进行自加1 运算后，ptr 指向了和整形变量a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。

而第 4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：我的指针究竟指向了哪里。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。

在指针的强制类型转换：**ptr1=(TYPE \*)ptr2** 中，如果 sizeof(ptr2的类型)大于 sizeof(ptr1 的类型)，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果 sizeof(ptr2 的类型) 小于sizeof(ptr1 的类型)，那么在使用指针ptr1 来访问ptr2 所指向的存储区时是不安全的。

## C回调函数

###0.简介

####函数指针作为某个函数的参数

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

```简体中文
以下是来自知乎作者常溪玲的解说：
你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。
```

```c
#include <stdlib.h>  
#include <stdio.h>
 
// 回调函数
void populate_array(int *array, size_t arraySize, int (*getNextValue)(void))
{
    int i;
  	for (size_t i=0; i<arraySize; i++)
        array[i] = getNextValue();
}
 
// 获取随机值
int getNextRandomValue(void)
{
    return rand();
}
 
int main(void)
{
    int i;
  	int myarray[10];
    populate_array(myarray, 10, getNextRandomValue);
    for(int i = 0; i < 10; i++) {
        printf("%d ", myarray[i]);
    }
    printf("\n");
    return 0;
}
/*
有关于 size_t:
size_t 是一种数据类型，近似于无符号整型，但容量范围一般大于 int 和 unsigned。这里使用 size_t 是为了保证 arraysize 变量能够有足够大的容量来储存可能大的数组。
*/
```

编译执行，输出结果如下：

```
16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709 
```

### 1.什么是回调函数

两种解释：

官方版：

把一段可执行的代码像参数传递那样传给其他代码，而这段代码会在某个时刻被调用执行，这就叫做回调。如果代码立即被执行就称为同步回调，如果在之后晚点的某个时间再执行，则称之为异步回调。

通俗易懂版：

函数 F1 调用函数 F2 的时候，函数 F1 通过参数给 函数 F2 传递了另外一个函数 F3 的指针，在函数 F2 执行的过程中，函数F2 调用了函数 F3，这个动作就叫做回调（Callback），而先被当做指针传入、后面又被回调的函数 F3 就是回调函数。

### 2.为什么要使用回调函数

回调函数最大的好处和作用：解耦。

![image-20200419151742631](/Users/apple 1 2/Library/Application Support/typora-user-images/image-20200419151742631.png)

呈现上图的代码：

```c
#include<stdio.h>
#include<softwareLib.h> // 包含Library Function所在读得Software library库的头文件

int Callback() // Callback Function
{
    // TODO
    return 0;
}
int main() // Main program
{
    // TODO
    Library(Callback);
    // TODO
    return 0;
}
```

乍一看，回调似乎只是函数间的调用，和普通函数调用没啥区别，但仔细一看，可以发现两者之间的一个关键的不同：在回调中，主程序把回调函数像参数一样传入库函数。这样一来，只要我们改变传进库函数的参数，就可以实现不同的功能，并且丝毫不需要修改库函数的实现，这就是解耦。

### 3.如何使用回调函数

```c
#include<stdio.h>

int Callback_1() // Callback Function 1
{
    printf("Hello, this is Callback_1 ");
    return 0;
}

int Callback_2() // Callback Function 2
{
    printf("Hello, this is Callback_2 ");
    return 0;
}

int Callback_3() // Callback Function 3
{
    printf("Hello, this is Callback_3 ");
    return 0;
}

int Handle(int (*Callback)())
{
    printf("Entering Handle Function. ");
    Callback();
    printf("Leaving Handle Function. ");
}

int main()
{
    printf("Entering Main Function. ");
    Handle(Callback_1);
    Handle(Callback_2);
    Handle(Callback_3);
    printf("Leaving Main Function. ");
    return 0;
}
/*
这个例子可以很好地诠释回调函数的意义。在用Handle调用其他函数时，我们并不需要再多次麻烦地修改Handle函数。
*/
```

运行结果：

```
Entering Main Function.
Entering Handle Function.
Hello, this is Callback_1
Leaving Handle Function.
Entering Handle Function.
Hello, this is Callback_2
Leaving Handle Function.
Entering Handle Function.
Hello, this is Callback_3
Leaving Handle Function.
Leaving Main Function.
```

**总结：**A "callback" is any function that is called by another function which takes the first function as a parameter.

### 4.怎么使用带参数的回调函数

前面的例子里面回调函数是没有参数的，那么我们能不能回调那些带参数的函数呢？答案是肯定的。那么怎么调用呢？我们稍微修改一下上面的例子就可以了：

```c
#include<stdio.h>

int Callback_1(int x) // Callback Function 1
{
    printf("Hello, this is Callback_1: x = %d ", x);
    return 0;
}

int Callback_2(int x) // Callback Function 2
{
    printf("Hello, this is Callback_2: x = %d ", x);
    return 0;
}

int Callback_3(int x) // Callback Function 3
{
    printf("Hello, this is Callback_3: x = %d ", x);
    return 0;
}

int Handle(int y, int (*Callback)(int))
{
    printf("Entering Handle Function. ");
    Callback(y);
    printf("Leaving Handle Function. ");
}

int main()
{
    int a = 2;
    int b = 4;
    int c = 6;
    printf("Entering Main Function. ");
    Handle(a, Callback_1);
    Handle(b, Callback_2);
    Handle(c, Callback_3);
    printf("Leaving Main Function. ");
    return 0;
}
```

运行结果：

```
Entering Main Function.
Entering Handle Function.
Hello, this is Callback_1: x = 2
Leaving Handle Function.
Entering Handle Function.
Hello, this is Callback_2: x = 4
Leaving Handle Function.
Entering Handle Function.
Hello, this is Callback_3: x = 6
Leaving Handle Function.
Leaving Main Function.
```

可以看到，并不是直接把int Handle(int (*Callback)()) 改成 int Handle(int (*Callback)(int)) 就可以的，而是通过另外增加一个参数来保存回调函数的参数值，像这里 int Handle(int y, int (*Callback)(int)) 的参数 y。同理，可以使用多个参数的回调函数。

## C字符串

###字符串函数

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

### 易错细节：

####1.字符串末尾的'\0'

字符串在以如下输入进行初始化的时候需要对 **\0** 特别注意：

```
char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
```

如果没有在字符数组最后增加 **\0** 的话输出结果有误：

```
// 初始化字符串
char greeting[5] = { 'H', 'e', 'l', 'l', 'o' };
printf("Greeting message: %s\n", greeting);
```

输出结果:

```
Greeting message: Hello烫烫烫?侵7(?╔?╚╔╔
```

在使用不定长数组初始化字符串时默认结尾为 **\0**

```
char greeting[] = "Hello";
printf("Greeting message: %s, greeting[] Length: %d\n", greeting, sizeof(greeting));
```

输出结果:

```
Greeting message: Hello, greeting[] Length: 6
```

####2.strlen和sizeof

strlen 是函数，sizeof 是运算操作符，二者得到的结果类型为 size_t，即 unsigned int 类型。

sizeof 计算的是变量的大小，不受字符 **\0** 影响；

而 strlen 计算的是字符串的长度，以 **\0** 作为长度判定依据。

## C结构体

### 1.基础知识

#### 1.1定义结构（含typedef创建结构体）

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```c
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;
```

**tag** 是结构体标签。

**member-list** 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。

**variable-list** 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：

```cc
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

在一般情况下，**tag、member-list、variable-list** 这 3 部分至少要出现 2 个。以下为实例：

```c
//1.
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//同时又声明了结构体变量s1
//这个结构体并没有标明其标签
struct 
{
    int a;
    char b;
    double c;
} s1;
 
//2.
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c
//结构体的标签被命名为SIMPLE,没有声明变量。因为1和2的标签不同（1没有标签），所以1和2会被编译器识别为不同的类型。
struct SIMPLE
{
    int a;
    char b;
    double c;
};
struct SIMPLE t1, t2[20], *t3;
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3 。因为没有声明变量，所以要另外加一行声明要使用的变量，而不能直接用var1.member1访问。

//3.
//也可以用typedef创建新类型（重要！！）
typedef struct
{
    int a;
    char b;
    double c; 
} Simple2;
//现在可以用Simple2作为类型声明新的结构体变量
Simple2 u1, u2[20], *u3;//注意这里！！！u1是一个结构体，u2是一个结构体数组，u3是一个结构体指针。
```

在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&s1，则是非法的。

结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

```c
//此结构体的声明包含了其他的结构体
struct COMPLEX
{
    char string[100];
    struct SIMPLE a;//这句话的意思相当于上例中的struct SIMPLE t1......
};
 
//此结构体的声明包含了指向自己类型的指针
struct NODE
{
    char string[100];
    struct NODE *next_node;
};
```

如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：

```c
struct B;    //对结构体B进行不完整声明
 
//结构体A中包含指向结构体B的指针
struct A
{
    struct B *partner;
    //other members;
};
 
//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明
struct B
{
    struct A *partner;
    //other members;
};
```

####1.2结构体变量的初始化

```c
#include <stdio.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book = {"C 语言", "RUNOOB", "编程语言", 123456};
 
int main()
{
    printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);
}
```

执行输出结果为：

```
title : C 语言
author: RUNOOB
subject: 编程语言
book_id: 123456
```

#### 1.3访问结构成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 **struct** 关键字来定义结构类型的变量。下面的实例演示了结构的用法：

```c
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printf( "Book 1 title : %s\n", Book1.title);
   printf( "Book 1 author : %s\n", Book1.author);
   printf( "Book 1 subject : %s\n", Book1.subject);
   printf( "Book 1 book_id : %d\n", Book1.book_id);
 
   /* 输出 Book2 信息 */
   printf( "Book 2 title : %s\n", Book2.title);
   printf( "Book 2 author : %s\n", Book2.author);
   printf( "Book 2 subject : %s\n", Book2.subject);
   printf( "Book 2 book_id : %d\n", Book2.book_id);
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
```

#### 1.4结构体作为函数参数

```c
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 输出 Book1 信息 */
   printBook( Book1 );
 
   /* 输出 Book2 信息 */
   printBook( Book2 );
 
   return 0;
}
void printBook( struct Books book )
{
   printf( "Book title : %s\n", book.title);
   printf( "Book author : %s\n", book.author);
   printf( "Book subject : %s\n", book.subject);
   printf( "Book book_id : %d\n", book.book_id);
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Book title : C Programming
Book author : Nuha Ali
Book subject : C Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
```

#### 1.5指向结构体的指针简述

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：

```c
struct Books *struct_pointer;
```

现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：

```c
struct_pointer = &Book1;
```

为了使用指向该结构的指针访问结构的成员，您必须使用 -> 运算符，如下所示：

```c
struct_pointer->title;
```

实例：

```c
#include <stdio.h>
#include <string.h>
 
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
};
 
/* 函数声明 */
void printBook( struct Books *book );
int main( )
{
   struct Books Book1;        /* 声明 Book1，类型为 Books */
   struct Books Book2;        /* 声明 Book2，类型为 Books */
 
   /* Book1 详述 */
   strcpy( Book1.title, "C Programming");
   strcpy( Book1.author, "Nuha Ali"); 
   strcpy( Book1.subject, "C Programming Tutorial");
   Book1.book_id = 6495407;
 
   /* Book2 详述 */
   strcpy( Book2.title, "Telecom Billing");
   strcpy( Book2.author, "Zara Ali");
   strcpy( Book2.subject, "Telecom Billing Tutorial");
   Book2.book_id = 6495700;
 
   /* 通过传 Book1 的地址来输出 Book1 信息 */
   printBook( &Book1 );
 
   /* 通过传 Book2 的地址来输出 Book2 信息 */
   printBook( &Book2 );
 
   return 0;
}
void printBook( struct Books *book )
{
   printf( "Book title : %s\n", book->title);
   printf( "Book author : %s\n", book->author);
   printf( "Book subject : %s\n", book->subject);
   printf( "Book book_id : %d\n", book->book_id);
}
```

#### 1.6其他问题

#####1.6.1结构体的内存分配

结构体中成员变量分配的空间是按照成员变量中占用空间最大的来作为分配单位,同样**成员变量的存储空间也是不能跨分配单位**的,（例如debug_size1_t中依次给a,b,c分配内存）如果当前的空间不足,则会存储到下一个分配单位中。

```c
#include <stdio.h>

typedef struct
{
    unsigned char a;
    unsigned int  b;
    unsigned char c;
} debug_size1_t;
typedef struct
{
    unsigned char a;
    unsigned char b;
    unsigned int  c;
} debug_size2_t;

int main(void)
{
    printf("debug_size1_t size=%lu,debug_size2_t size=%lu\r\n", sizeof(debug_size1_t), sizeof(debug_size2_t));
    return 0;
}
```

编译执行输出结果：

```
debug_size1_t size=12,debug_size2_t size=8
```

结构体占用存储空间,以32位机为例

-  1.debug_size1_t 存储空间分布为a(1byte)+空闲(3byte)+b(4byte)+c(1byte)+空闲(3byte)=12(byte)。
-  1.debug_size2_t 存储空间分布为a(1byte)+b(1byte)+空闲(2byte)+c(4byte)=8(byte)。

### 2.结构体详述

#### 2.1内容回顾

结构体相当于其它高级语言中的记录(dictionary)。

声明一个结构休类型的一般形式如下：

```c
struct 结构体名
{成员列表};
```

结构体名，用作结构体类型的标志，它又称结构体标记。

####2.2结构体变量的定义

前面只是指定了一个结构体类型，它相当于一个模型，但其中并无具体数据，系统对之也不分配实际内存单元，为了能在程序中使用结构类型的数据，应当定义结构体类型的变量，并在其中存放具体的数据，可以采取以下3种方法定义结构体类型变量。

（1）先声明结构体类型再定义变量名

如上面已定义了一个结构体类型 struct student，可以用它来定义变量。如：

```
struct student{  //结构体类型名
    ...
    ...
    ...
}student1, student2 //结构体变量名
```

定义了 student1, student2 为 struct student 类型的变量。

在定义了结构体变量后，系统会为之分配内存单元。例如 student1 和 student2 在内存中各占 59 个字节。

应当注意，将一个变量定义为标准类型（基本数据类型）与定义为结构体类型不同之处在于后者不仅要求指定变量为结构体类型，而且要求指定为某一特定的结构体类型（例如 struct student 类型），因为可以定义出许多种具体的结构体类型。而在定义变量为整形时，只需指定为 int 型即可。

（2）在声明类型的同时定义变量

例如：

```
struct student
{
    int num;
    char name[20];
    char sex;
    int age;
    float score;
    char addr[30];
}student1, student2;
```

它的作用与第一种方法相同，即定义了两个 struct student 类型的变量 student1, student2 这种形式的定义的一般形式为

```
struct 结构体名
{
    成员表列
}变量名表列;
```

（3）直接定义结构类型变量

其一般形式为:

```
struct
{
    成员表列
}变量名表列;
```

即不出现结构体名。

关于结构体类型，有几点要说明：

- a. 类型与变量是不同的概念，不是混同，只能对变量赋值，存取或运算，而不能对一个类型赋值，存取或运算。在编译时，对类型是不分配空间的，只对变量分配空间。
- b. 对结构体中的成员（即 域）可以单元使用，它的作用与地位相当于普通变量。
- c. 成员也可以是一个结构体变量。如：

```c
struct date // 声明一个结构体类型
{
    int month;
    int day;
    int year;
}

struct student
{
    int num;
    char name[20];
    char sex;
    int age;
    struct date birthday;
    char addr[30];
}student1, student2;
```

先声明一个 struct date 类型，它代表 日期 包括3个成员 month, day, year。然后在声明 struct student 类型时，将成员 birthday 指定为 struct date 类型。

- d. **成员名可以与程序中的变量名相同，二者不代表同一对象。**

#### 2.3结构体变量的引用

**（1）不能将一个结构体变量作为一个整体进行输入和输出。**

只能对结构体变量中的各个成员分别进行输入输出。引用结构体变量中的成员的方式为：

```
结构体变量名.成员名
```

例如 student1.num 表示 student1 变量中的 num 成员，即 student1 的 num 项，可以对变量的成员赋值。例如： student1.num = 10010;

**.** 是成员（分量）运算符，它在所有的运算符中优先级最高，因此可以把 student1.num 作为一个整体来看待。上面的赋值语句作用是将整数 10010赋给 student1 变量中的成员 num。

**（2）如果成员本身又属一个结构体类型，则要用若干个成员运算符，一级一级地找到最低一级的成员。只能对最低的成员进行赋值或存取以及运算。**

例如：结构体变量 student1 可以这样访问各成员：

```
student1.num
student1.birthday.month
```

注意，不能用 student1.birthday 来访问 student1 变量中的成员 birthday，因为 birthday 本身是一个结构体变量。

**（3）对结构体变量的成员可以像普通变量一样进行各种运算（根据其类型决定可以进行的运算）。**

```
student2.score = student1.score;
sum = student1.score + student2.score;
student1.age ++;
++ student1.age;
```

<span style="color:red;background-color:yellow">由于 **.** 运算符的优先级最高，因此 student1.age ++ 是对 student1.age 进行自加运算。而不是先对 age 进行自加运算。</span>

**（4）可以引用结构体变量成员的地址。也可以引用结构体变量的地址。如：**

```
scanf("%d", &student1.num);// 输入 student1.num 的值
printf("%o", &student1);// 输出 student1 的首地址
```

但不能用以下语句整体读入结构体变量如：

```
scanf("%d,%s,%c,%d,%f,%s", &student1);
```

<span style="color:red;background-color:yellow">结构体变量的地址主要用于作函数参数，传递结构体的地址。</span>

#### 2.4结构体变量的初始化

同1.x中，只需指定一个初值即可。

```c
#include <stdio.h>
struct student
{
    long int num;
    char name[20];
    char sex;
    char addr[30];
}a = {89031, "Li Lin", 'M', "123 Beijing Road"};
 
void main()
{
    printf("NO. : %ld\nname: %s\nsex: %c\naddress: %s\n", a.num, a.name, a.sex, a.addr);
}
```

####<span style="color:red;background-color:yellow">2.5结构体数组</span>

一个结构体变量中可以存放一组数据（如一个学生的学号，姓名，成绩等数据）。如果有10个学生的数据需要参加运算，显然应该用数组，这就是结构体数组。结构体数组与以前介绍过的数据值型数组不同之处在于<span style="color:red;background-color:yellow">每个数组元素都是一个结构体类型的数据</span>，它们分别包括各个成员（分量）项。

##### 2.5.1定义结构体数组

和定义结构体变量的方法相仿，只需说明其为数组即可。

```c
struct student
{
    int num;
    char name[20];
    char sex;
    int age;
    float score;
    char addr[30];
};
struct student stu[3];
```

以上定义了一个数组 stu，其元素为 struct student 类型数据，数组有 3 个元素。也可以直接定义一个结构体数组。如：

```
struct student
{
    int num;
    ....

}stu[3];

或

struct

{
    int num;
    　...
}stu[3];
```

##### 2.5.2结构体数组的初始化

与其它类型数组一样，对结构体数组可以初始化如：

```c
struct student
{
    int mum;
    char name[20];
    char sex;
    int age;
    float score;
    char addr[30];
}stu[3] = {{10101,"Li Lin", 'M', 18, 87.5, "103 Beijing Road"},
            {10101,"Li Lin", 'M', 18, 87.5, "103 Beijing Road"},
            {10101,"Li Lin", 'M', 18, 87.5, "103 Beijing Road"}};
```

定义数组 stu 时，元素个数可以不指定，即写成以下形式：

```c
stu[] = {{...},{...},{...}};
```

编译时，系统会根据给出初值的结构体常量的个数来确定数组元素的个数。

当然，数组的初始化也可以用以下形式：

```
struct student
{
    int num;
    ...
};
struct student stu[] = {{...},{...},{...}};
```

即先声明结构体类型，然后定义数组为该结构体类型，在定义数组时初始化。

##### 2.5.3应用举例

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
 
struct person
{
    char name[20];
    int count;
 
}leader[3] = {{"Li", 0},
            　{"Zhang", 0},
            　{"Fun", 0}};
 
void main()
{
    int i, j;
    char leader_name[20];
    for(i = 1; i<= 10;i++)
    {
        scanf("%s", leader_name);
        for(j=0;j<3;j++)
            if(strcmp(leader_name, leader[j].name) == 0)
                leader[j].count ++;
    }
    printf("\n");
    for(i=0;i<3;i++)
        printf("%5s: %d\n", leader[i].name, leader[i].count);
    system("pause");
}
```

运行结果如下：

```
输入：
LI
Li
Fun
Zhang
Zhang
Fun
Li
Fun
Zhang
Li
输出：
   Li: 3
Zhang: 3
  Fun: 3
```

#### 2.6指向结构体类型数据的指针

一个结构体变量的指针就是该变量所占据的内存段的起始地址，可以设一个指针变量，用来指向一个结构体变量，此时该指针变量的值是结构体变量的起始地址。指针变量也可以用来指向结构体数组中的元素。

##### 2.6.1指向结构体变量的指针

示例：

```c
#include <string.h>
#include <stdio.h>
#include <stdlib.b>
 
struct student
{
    long num;
    char name[20];
    char sex;
    float score;
};
 
void main()
{
    struct student stu_1;
    struct student *p;
    p = &stu_1;
    stu_1.num = 89101;
    strcpy(stu_1.name, "Li Lin");
    stu_1.sex = 'M';
    stu_1.score = 89.5;
    printf("NO. :%ld\nname: %s\nsex:%c\nscore:%f\n", stu_1.num, stu_1.name, stu_1.sex, stu_1.score);
    printf("NO. :%ld\nname: %s\nsex:%c\nscore:%f\n", (*p).num, (*p).name, (*p).sex, (*p).score);
    system("pause");
}
```

在主函数中声明了 struct student 类型，然后定义了一个 struct student 类型的变量，stu_1 同时又定义一个指针变量 p ，它指向一个 struct student 类型的数据，在函数的执行部分将结构体变量 stu_1 的起始地址赋给指针变量 p ，也就是使 p 指向 stu_1 然后对 stu_1 的各成员赋值，第二个 printf 函数也是用来输出 stu_1 各成员的值，但使用的是 (*p).num 这样的形式， (*p) 表示 p 指向的结构体变量，(*p).num 是 p 指向的结构体变量中的成员 num 。注意 *p 两侧的括弧不可省略，因为成员运算符 '.' 优先于 '*' 运算符，*p.num 就等价于 *(p.num)

运行结果如下：

```
NO. :89101
name: Li Lin
sex:M
score:89.500000
NO. :89101
name: Li Lin
sex:M
score:89.500000
```

可以看到两个 printf 输出的结果相同。

在C语言中，为了使用方便和使之直观，可以把 (*p).num 改用 p->num 来代替，它表示 *p 所指向的结构体变量中的 num 成员，同样，(*p).name 等价于 p->name。

也就是说以下三种形式等价：

- a. **结构体变量.成员名**
- b. **(\*p).成员名**
- c. **p-> 成员名**

上面的最后一个 printf 函数输了项可以改写为:

```
printf("NO. :%ld\nname: %s\nsex:%c\nscore:%f\n",p->num, p->name, p->sex, p->score);
```

其中 **->** 称为指向运算符。

##### 2.6.2指向结构体数组的指针

```c
#include <stdio.h>
#inlcude <stdlib.h>
 
struct student
{
    int num;
    char name[20];
    char sex;
    int age;
};
 
struct student stu[3] = {{10101, "Li Lin", 'M', 18},
                        　{10102, "Zhang Fun", 'M', 19},
                        　{10103, "Wang Min", 'F', 20}};
 
int main()
{
    struct student *p;
    printf("No.    name        sex        age\n");
    for(p=stu; p<stu+3;p++)
        printf("%5d %-20s %2c %4d\n", p->num, p->name, p->sex, p->age);
    system("pause");
		//注意，与数组和指针的知识点相同，p++会使p右移sizeof(指向数据类型)个bit。
}
```

运行结果如下：

```
No.    name        sex        age
10101 Li Lin                M       18
10102 Zhang Fun        M       19
10103 Wang Min          F        20
```

**注意以下两点：**

（1）如果 p 的初值为 stu，即指向第一个元素，则 p + 1 后指向下一个元素的起始地址。例如：

(++p) -> num 先使 p 自加 1 ，然后得到它指向的元素中的 num 成员的值（即10102）。

(p++) ->num 先得到 p->num 的值（即10101），然后使 p 自加 1 ，指向 stu[1]。

注意以上二者的不同。这本质上还是p++和++p两个表达式的值的问题。

（2）<span style="color:red;background-color:yellow">程序已定义了指针 p 为指向 struct student 类型数据的变量，它只能指向一个 struct student 型的数据</span>（p 的值是 stu 数组的一个元素的起始地址），而不能指向 stu 数组元素中的某一成员，（即 p 的地址不能是成员地址）。例如，下面是不对的：

```
p = &stu[1].name
```

编译时将出错。千万不要认为反正 p 是存放地址的，可以将任何地址赋给它。<span style="color:red;background-color:yellow">如果地址类型不相同，可以用强制类型转换。</span>例如：

```
p = (struct student *)&stu[1].name;
```

此时，在 p 中存放 stu[1] 元素的 name 成员的起始地址。

##### 2.6.3用结构体变量和指向结构体的指针做函数参数

将一个结构体变量的值传递给另一个函数，有3个方法：

- （1）用结构体变量的成员作参数，例如：用 stu[1].num 或 stu[2].name 作函数实参，将实参值传给形参。用法和用普通变量作实参是一样的，属于 值传递 方式。应当注意实参与形参的类型保持一致。
- （2）用结构体变量作参数。老版本的C系统不允许用结构体变量作实参，ANSI C取消了这一限制。但是用结构体变量作实参时，采取的是 值传递 的方式，将结构体变量所占的内存单元全部顺序传递给形参。形参也必须是同类型的结构体变量。在函数调用期间形参也要占用内存单元。这种传递方式在空间和时间上开销较大，如果结构体的规模很大时，开销是很可观的，此外由于采用值传递方式，如果在执行被调用函数期间改变了形参（也是结构体变量）的值，该值不能返回主调函数，这往往造成使用上的不便。因此一般较少用这种方法。
- （3）用指向结构体变量（或数组）的指针作实参，将结构体变量（或数组）的地址传给形参。

用结构体变量作函数参数。（复习）

示例：

```c
#include <stdio.h>
#define FORMAT "%d\n%s\n%f\n%f\n%f\n"
 
struct student
{
    int num;
    char name[20];
    float score[3];
};
 
void print(struct student stu)
{
    printf(FORMAT, stu.num, stu.score[0], stu.score[1], stu.score[2]);
    printf("\n");
}
 
void main()
{
    struct student stu;
    stu.num = 12345;
    strcpy(stu.name, "Li Li");
    stu.score[0] = 67.5;
    stu.score[1] = 89;
    stu.score[2] = 78.6;
    printf(stu);
}
```

改用指向结构体变量的指针做实参：

```c
#include <stdio.h>
#define FORMAT "%d\n%s\n%f\n%f\n%f\n"
 
struct student
{
    int num;
    char name[20];
    float score[3];
}stu = {12345, "Li Li", 67.5, 89, 78.6};
//这里也可写为{12345, "Li Li",{67.5, 89, 78.6}}
 
void print(struct student *p)
{
    printf(FORMAT, p->num, p->name, p->score[0], p->score[1], p->score[2]);
    printf("\n");
}
 
void main()
{
    print(&stu);
}
```

####2.7链表

#####2.7.1链表概述

链表是一种常见的重要的数据结构。它是动态地进行存储分配的一种结构。

链表有一个 头指针 变量，它存放一个地址，该地址指向一个元素，链表中每一个元素称为 结点，每个结点都应包括两个部分，一为用户需要用的实际数据，二为下一个结点的地址。可以看出，头指针 head 指向第一个元素，第一个元素又指向第二个元素，。。。。直到最后一个元素，该元素不再指向其他元素，它称为 表尾，它的地址部分放一个 NULL（表示 空地址）链表到此结束。

**可以看到链表中各元素在内存中可以不是连续存放的**，要找某一元素，必须先找到上一个元素，根据它提供的下一元素地址才能找到下一个元素。如果不提供 头指针 head 则整个链表无法访问。

可以看到。这种链表的数据结构，必须利用指针变量才能实现，即一个结点中应包含一个指针变量，用它存放下一结点的地址。

前面介绍了结构体变量，用它作链表中的结点是最合适的，一个结构体变量包含若干成员，这些成员可以是数值类型，字符类型，数组类型，也可以是指针类型，我们用这个指针类型成员来存放下一个结点的地址。例如可以设计这样一个结构体类型：

```c
struct student
{
    int num;
    float score;
    struct student *next;
};
```

其中成员 num 和 score 用来存放结点中的有用数据（用户需要用到的数据），next 是指针类型成员，它指向 struct student 类型数据（这是 next 所在结构体类型）。一个指针类型的成员既可以指向其他类型的结构体数据，也可以指向自己所在的结构体类型的数据。现在 next 是 struct student 类型中的一个成员，它又指向 struct student 类型的数据。用这种方法就可以建立链表。

请注意：只是定义一个 struct student 类型，并未实际分配存储空间，只有定义了变量才分配内存单元。

##### 2.7.2简单链表

```c
#include <stdio.h>
#include <stdlib.h>
 
#define NULL 0
 
struct student
{
    long num;
    float score;
    struct student *next;
};
 
void main()
{
    struct student a, b, c, *head, *p;
    a.num = 99101; a.score = 89.5;
    b.num = 99103; b.score = 90;
    c.num = 99107; c.score = 85;//对结点的 num 和 score 成员赋值
    head = &a;//将结点 a 的起始地址赋给头指针 head
    a.next = &b;//将结点 b 的起始地址赋给 a 结点的 next 成员
    b.next = &c;
    c.next = NULL;// c 结点的 next 成员不存放其他结点地址
    p = head;//使 p 指针指向 a 结点
    do
    {
        printf("%ld %5.1f\n", p->num, p->score);// 输出 p 指向的结点的数据
        p = p->next;//使 p 指向下一结点
    }while(p != NULL);//输出完 c 结点后 p 的值为 NULL
    system("pause");
}
```

运行结果:

```
99101  89.5
99103  90.0
99107  85.0
```

##### 2.7.3处理动态链表所需的函数

**（1）malloc 函数**

```
void *malloc(unsigned int size);
```

作用是在内存的动态存储区中分配一个长度为 size 的连接空间。函数的值（即返回值）是一个指向分配空间起始地址的指针（基类型为 void）。如果些函数未能成功地执行（例如内存空间不足）则返回空指针 NULL。

**（2）calloc 函数**

```
void *calloc(unsigned n, unsigned size);
```

其作用是在内存的动态区存储中分配 n 个长度为 size 的连续空间。函数返回一个指向分配空间起始地址的指针，如果分配不成功，返回 NULL。 用 calloc 函数可以为一维数组开辟动态存储空间， n 为数组元素个数，每个元素长度为 size。

**（3）free 函数**

```
void free(void *p);
```

其作用是释放由 p 指向的内存区，使这部分内存区能被其它变量使用， p 是最后一次调用 calloc 或 malloc 函数时返回的值。free 函数无返回值。 请注意：以前的C版本提供的 malloc 和 calloc 函数得到的是指向字符型数据的指针。ANSI C 提供的 malloc 和 calloc 函数规定为 void * 类型。

##### 2.7.4建立动态链表

所谓建立动态链表是指在程序执行过程中从无到有地建立起一个键表，即一个一个地开辟结点和输入各结点数据，并建立起前后相链的关系。

```c
#include <stdio.h>
#include <stdlib.h>
 
#define NULL 0
#define LEN sizeof(struct student)
 
struct student
{
    long num;
    float score;
    struct student *next;
};
 
struct student *create()
{
    struct student *p1, *p2, *head;
    int num;
    float score;
    int n = 0;
 
    head = NULL;
 
    p1 = p2 = (struct student *)malloc(LEN);//malloc返回指向分配到空间起始地址的指针。此处返回的这个指针类型是void，因此需要强制类型转换。
 
    printf("please input num and score.\n");
    scanf("%d,%f", &p1->num, &p1->score);//->的优先级高于&
 
    while(p1->num != 0)
    {
        n ++;
        if(n == 1)
            head = p1;
        else
            p2->next = p1;
        p2 = p1;
        p1 = (struct student *)malloc(sizeof(struct student));
 
        printf("please input num and score.\n");
 
        scanf("%d,%f", &p1->num, &p1->score);
    }//只要输入的num不为0，生成的链表就是无限长的。
    p2->next = NULL;
    return head;
}
/*上面的函数详解：（输入4次为例）
head置为空指针NULL，n置0。
p1，p2都指向新分配空间（设为空间1）的起始地址。此时根据强制类型转换，它们都指向一个结构体struct1。
第1次输入num1!=0,score1后，p1所在的地址所指向的结构体struct1中有了num1和score1两个元素。p2也占有相同的地址，它指向的结构体也是struct1。
进入循环
如果n==1，也就是说程序第一次进入这个循环，那么把p1赋值给head，从而head指向第一次输入后p1所指向的结构体struct1。
把p1的值赋给p2（之后的循环中有用，但对第一次可有可无，第一次p2本来就等于p1。），再申请一块新的内存空间，记为空间2，p1指向空间2的起始地址，也就是说，p1指向一个新的结构体struct2。注意此时struct2的各个元素都未赋值。
第2次输入num2!=0,score2后，struct2已经有了num2和score2两个具体值。再次重复while循环：
程序不是第一次进入循环了，因此走else，把p1现有的地址（这个地址此时已经指向struct2了）赋给p2指向的结构体struct1中的next元素。
把p1现有的地址赋值给p2，此时p2也指向struct2。但是注意到，此时head指向struct1，struct1的next指向struct2，链表已经有了雏形。
再给p1开一块新的内存空间空间3，p1指向结构体struct3。
第三次输入num3!=0,score3，进入while循环。struct3已经有两个值了。
程序走else，把p1现有的地址（指向struct3）赋值给p2->next。p2指向struct2，因此struct2.next指向struct3。
再次把p1现有的地址赋给p2，让p2指向struct3。此时head指向struct1，struct1.next指向struct2，struct2.next指向struct3.（这几块内存未必是连续的！）
再给p1开一块新的内存空间空间4，p1指向struct4。这时候struct4是空的。
第四次输入num4==0，score4后，跳出循环。（这代表着用户只需要num1,num2,num3的数据，num4只是一个终止信号）
p2此时指向struct3，把struct3.next赋值为NULL。
一个完整的链表就这么形成了。
*/
 
void printlist(struct student *head)
{
    struct student *p;
    p = head;
    if(head != NULL)
    {
        do
        {
            printf("num=%d score=%f\n", p->num, p->score);
            p = p->next;
        }while(p != NULL);//p从head（也就是struct1的地址）开始，每次打印完之后一直往后变成struct2的地址，struct3的地址......一直到structn的地址，如果它指向NULL，则结束循环，全部结构体中的信息打印完毕。
    }
}
 
void main()
{
    struct student *head;
    head = create();
    printlist(head);
    system("pause");
}
```

**以下是对链表的各种操作**

打印链表:

```c
void printlist(struct student *head)
{
    struct student *p;
    p = head;

    if(head != NULL)
    {
        do 
        {
            printf("num=%d score=%5.2f\n", p->num, p->score);
            p = p->next;
        } while (p != NULL);
    }
    /* while(p -> next != NULL)
    {
        printf("num=%d score=%f\n", p->num, p->score);
        p = p->next;
    }*/
}
```

删除节点:

```c
struct student *delNode(struct student *head, int num)
{
    printf("delNode.\n");
    struct student *p1, *p2;
    if(head == NULL)
    {
        printf("The List is NULL.\n");
    }
    else
    {
        p1 = head;
        while(p1->next != NULL && p1->num != num)
        {
            p2 = p1;
            p1 = p1->next;
        }
        if(p1->num == num)
        {
            if(p1 == head)
                head = p1->next;
            else
                p2->next = p1->next;
        }
        else
            printf("Can not find list num.\n");
    }
    return head;
}
//理解了第一个程序后，之后几个很好理解。
```

更新节点:

```c
struct student *update(struct student *head, int index, int num, float score)
{
    printf("update.\n");
    struct student *p;
    if(head == NULL)
    {
        printf("The List is NULL.\n");
    }
    else
    {
        p = head;
        while(p->next != NULL && p->num != index)
        {
            p = p->next;
        }
        if(p->num == index)
        {
            p->num = num;
            p->score = score;
        }
        else
            printf("Can not find list index.\n");
    }
    return head;
}
```

增加节点:

```c
struct student *add(struct student *head, int index, int num, float score)
{
    printf("add.\n");
    struct student *p1, *p2, *p3;
    if(head == NULL)
    {
        printf("The List is NULL.\n");
    }
    else
    {
        p1 = p2 = head;
        while(p1->next != NULL && p1->num != index)
        {
            p1 = p1->next;
            p2 = p1;//这里两行的顺序没错！p1,p2必须是保持相同的！
        }
        if(p1->num == index)
        {
            p3 = (struct student *)malloc(LEN);
            p3->num = num;
            p3->score = score;

            if(p2->next == NULL)
            {
                p2->next = p3;
                p3->next = NULL;
            }
            else
            {
                p3->next = p2->next;
                p2->next = p3;   
            }
        }
        else
            printf("Can not find list index.\n");
    }
    return head;
}
//疑问：p2存在的意义何在？为何不能只用p1？
```

## C内存管理

C 语言为内存的分配和管理提供了几个函数。这些函数可以在 **** 头文件中找到。

| 序号 | 函数和描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | **void \*calloc(int num, int size);** 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 |
| 2    | **void free(void \*address);**  该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 |
| 3    | **void \*malloc(int num);**  在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 |
| 4    | **void \*realloc(void \*address, int newsize);**  该函数重新分配内存，把内存扩展到 **newsize**。 |

**注意：**void * 类型表示未确定类型的指针。C、C++ 规定 void * 类型可以通过类型转换强制转换为任何其它类型的指针。

### 动态分配内存

编程时，如果您预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：

```
char name[100];
```

但是，如果您预先不知道需要存储的文本长度，例如您想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
int main()
{
   char name[100];
   char *description;
 
   strcpy(name, "Zara Ali");
 
   /* 动态分配内存 */
   description = (char *)malloc( 200 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student in class 10th");
   }
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
```

上面的程序也可以使用 **calloc()** 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：

```
calloc(200, sizeof(char));
```

当动态分配内存时，您有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。

### 重新调整内存的大小和释放内存

当程序退出时，操作系统会自动释放所有分配给程序的内存，但是，建议您在不需要内存时，都应该调用函数 **free()** 来释放内存。

或者，您可以通过调用函数 **realloc()** 来增加或减少已分配的内存块的大小。让我们使用 realloc() 和 free() 函数，再次查看上面的实例：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
int main()
{
   char name[100];
   char *description;
 
   strcpy(name, "Zara Ali");
 
   /* 动态分配内存 */
   description = (char *)malloc( 30 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcpy( description, "Zara ali a DPS student.");
   }
   /* 假设您想要存储更大的描述信息 */
   description = (char *) realloc( description, 100 * sizeof(char) );
   if( description == NULL )
   {
      fprintf(stderr, "Error - unable to allocate required memory\n");
   }
   else
   {
      strcat( description, "She is in class 10th");
   }
   
   printf("Name = %s\n", name );
   printf("Description: %s\n", description );
 
   /* 使用 free() 函数释放内存 */
   free(description);
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Name = Zara Ali
Description: Zara ali a DPS student.She is in class 10th
```

您可以尝试一下不重新分配额外的内存，strcat() 函数会生成一个错误，因为存储 description 时可用的内存不足。

### 小技巧：动态可变长的结构体

动态可变长的结构体：

```
typedef struct
{
  int id;
  char name[0];
}stu_t;
```

定义该结构体，只占用4字节的内存，name不占用内存。

```
stu_t *s = NULL;    //定义一个结构体指针
s = malloc(sizeof(*s) + 100);//sizeof(*s)获取的是4，但加上了100，4字节给id成员使用，100字节是属于name成员的
s->id = 1010;
strcpy(s->name,"hello");
```

注意：一个结构体中只能有一个可变长的成员，并且该成员必须是最后一个成员。

## C文件读写

一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件

### 打开文件

您可以使用 **fopen( )** 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 **FILE** 的一个对象，类型 **FILE** 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：

```
FILE *fopen( const char * filename, const char * mode );
```

在这里，**filename** 是字符串，用来命名文件，访问模式 **mode** 的值可以是下列值中的一个：

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 打开一个已有的文本文件，允许读取文件。                       |
| w    | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |
| a    | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |
| r+   | 打开一个文本文件，允许读写文件。                             |
| w+   | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |
| a+   | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |

如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

```
"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
```

### 关闭文件

为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：

```
 int fclose( FILE *fp );
```

如果成功关闭文件，**fclose( )** 函数返回零，如果关闭文件时发生错误，函数返回 **EOF**。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 **stdio.h** 中的常量。

C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。

### 写入文件

下面是把字符写入到流中的最简单的函数：

```
int fputc( int c, FILE *fp );
```

函数 **fputc()** 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 **EOF**。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：

```
int fputs( const char *s, FILE *fp );
```

函数 **fputs()** 把字符串 **s** 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 **EOF**。您也可以使用 **int fprintf(FILE \*fp,const char \*format, ...)** 函数来写把一个字符串写入到文件中。尝试下面的实例：

> **注意：**请确保您有可用的 **tmp** 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。
>
> **/tmp** 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: **C:\tmp**、**D:\tmp**等。

```c
#include <stdio.h>
 
int main()
{
   FILE *fp = NULL;
 
   fp = fopen("/tmp/test.txt", "w+");
   fprintf(fp, "This is testing for fprintf...\n");
   fputs("This is testing for fputs...\n", fp);
   fclose(fp);
}
```

当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 **test.txt**，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。

### 读取文件

下面是从文件读取单个字符的最简单的函数：

```
int fgetc( FILE * fp );
```

**fgetc()** 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 **EOF**。下面的函数允许您从流中读取一个字符串：

```
char *fgets( char *buf, int n, FILE *fp );
```

函数 **fgets()** 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 **buf**，并在最后追加一个 **null** 字符来终止字符串。

如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 **int fscanf(FILE \*fp, const char \*format, ...)** 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。

```c
#include <stdio.h>
 
int main()
{
   FILE *fp = NULL;
   char buff[255];
 
   fp = fopen("/tmp/test.txt", "r");
   fscanf(fp, "%s", buff);
   printf("1: %s\n", buff );
 
   fgets(buff, 255, (FILE*)fp);
   printf("2: %s\n", buff );
   
   fgets(buff, 255, (FILE*)fp);
   printf("3: %s\n", buff );
   fclose(fp);
}
```

当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：

```
1: This
2: is testing for fprintf...

3: This is testing for fputs...
```

首先，**fscanf()** 方法只读取了 **This**，因为它在后边遇到了一个空格。其次，调用 **fgets()** 读取剩余的部分，直到行尾。最后，调用 **fgets()** 完整地读取第二行。

### 二进制I/O函数

下面两个函数用于二进制输入和输出：

```c
size_t fread(void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
              
size_t fwrite(const void *ptr, size_t size_of_elements, 
             size_t number_of_elements, FILE *a_file);
```

这两个函数都是用于存储块的读写 - 通常是数组或结构体。

### fseek函数

fseek 可以移动文件指针到指定位置读,或插入写:

```
int fseek(FILE *stream, long offset, int whence);
```

fseek 设置当前读写点到 offset 处, whence 可以是 SEEK_SET,SEEK_CUR,SEEK_END 这些值决定是从文件头、当前点和文件尾计算偏移量 offset。

你可以定义一个文件指针 **FILE \*fp**,当你打开一个文件时，文件指针指向开头，你要指到多少个字节，只要控制偏移量就好，例如, 相对当前位置往后移动一个字节：**fseek(fp,1,SEEK_CUR);** 中间的值就是偏移量。 如果你要往前移动一个字节，直接改为负值就可以：**fseek(fp,-1,SEEK_CUR)**。

执行以下实例前，确保当前目录下 **test.txt** 文件已创建：

```
#include <stdio.h>

int main(){   
    FILE *fp = NULL;
    fp = fopen("test.txt", "r+");  // 确保 test.txt 文件已创建
    fprintf(fp, "This is testing for fprintf...\n");   
    fseek(fp, 10, SEEK_SET);
    if (fputc(65,fp) == EOF) {
        printf("fputc fail");   
    }   
    fclose(fp);
}
```

执行结束后，打开 test.txt 文件：

```
This is teAting for fprintf...
```

**注意：** 只有用 **r+** 模式打开文件才能插入内容，**w** 或 **w+** 模式都会清空掉原来文件的内容再来写，**a** 或 **a+** 模式即总会在文件最尾添加内容，哪怕用 fseek() 移动了文件指针位置。

### fopen不安全的解决办法

在代码首行写上:

```
#define _CRT_SECURE_NO_WARNINGS
```

定义宏忽略警告, 即可忽略安全警告, 生成运行。

